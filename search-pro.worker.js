const{entries:V}=Object,{fromEntries:et}=Object,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":79,\"nextId\":79,\"documentIds\":{\"0\":\"0\",\"1\":\"1\",\"2\":\"2\",\"3\":\"3\",\"4\":\"4\",\"5\":\"5\",\"6\":\"5#introduction\",\"7\":\"5#design\",\"8\":\"5#整体架构\",\"9\":\"5#区块数据结构\",\"10\":\"5#交易处理\",\"11\":\"5#流程概述\",\"12\":\"5#存储节点交易执行流程\",\"13\":\"5#共识节点交易提交流程\",\"14\":\"6\",\"15\":\"7\",\"16\":\"7#背景\",\"17\":\"7#总体架构\",\"18\":\"7#写流程\",\"19\":\"7#读流程\",\"20\":\"8\",\"21\":\"8#lsm\",\"22\":\"8#memtable\",\"23\":\"8#sstable\",\"24\":\"8#wal\",\"25\":\"8#manifest\",\"26\":\"9\",\"27\":\"10\",\"28\":\"10#条款1-理解模板型别推导\",\"29\":\"10#函数模板形式\",\"30\":\"10#paramtype为指针或者引用-而非万能引用\",\"31\":\"10#paramtype为万能引用\",\"32\":\"10#paramtype既非指针也非引用\",\"33\":\"10#特殊情况\",\"34\":\"10#条款2-理解auto类型推导\",\"35\":\"10#型别推导\",\"36\":\"10#初始化\",\"37\":\"10#条款3-理解decltype\",\"38\":\"10#条款4-掌握查看型别推导结果的方法\",\"39\":\"11\",\"40\":\"11#条款5-优先考虑auto而非显式声明\",\"41\":\"11#条款6-如果auto推导不符合预期-使用显式型别初始化\",\"42\":\"12\",\"43\":\"12#条款7-区别使用-和-创建对象\",\"44\":\"12#条款8-优先考虑使用nullptr而不是0和null\",\"45\":\"12#条款9-有限考虑使用using声明别名而不是typedef\",\"46\":\"12#条款10-优先考虑使用限定域的枚举而不是非限定域的枚举\",\"47\":\"12#条款11-优先考虑使用delete而不是private未定义函数\",\"48\":\"12#条款12-使用override声明重载函数\",\"49\":\"12#条款13-优先考虑const-iterator而非iterator\",\"50\":\"12#条款14-只要函数不抛出异常请使用noexcept\",\"51\":\"12#c-异常处理流程\",\"52\":\"12#为什么要加上noexcept\",\"53\":\"12#noexcept相关注意事项\",\"54\":\"12#条款15-尽可能地使用constexpr\",\"55\":\"12#constexpr修饰变量\",\"56\":\"12#constexpr修饰函数\",\"57\":\"12#constexpr修饰自定义类对象\",\"58\":\"12#条款16-保证const成员地线程安全\",\"59\":\"12#条款17-理解特种函数的生成机制\",\"60\":\"12#特种函数\",\"61\":\"12#生成机制\",\"62\":\"13\",\"63\":\"13#条款18-对于独占资源使用std-unique-ptr\",\"64\":\"13#条款19-对于共享资源使用std-shared-ptr\",\"65\":\"13#引用计数\",\"66\":\"13#自定义析构函数\",\"67\":\"13#shared-from-this\",\"68\":\"13#条款20-当std-shared-ptr可能悬空时使用std-weak-ptr\",\"69\":\"13#条款21-优先考虑使用std-make-unique和std-make-shared-而非直接使用new\",\"70\":\"13#适用make系列函数构造情形\",\"71\":\"13#情形一-避免潜在内存泄漏\",\"72\":\"13#情形二-避免多次内存分配\",\"73\":\"13#不适用make系列函数构造情形\",\"74\":\"13#使用自定义构造器\",\"75\":\"13#构造函数匹配问题\",\"76\":\"13#高内存占用对象以及生命周期就的weak-ptr\",\"77\":\"13#条款22-当使用pimpl惯用法-请在实现文件中定义特殊成员函数\",\"78\":\"14\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1,2],\"2\":[1],\"3\":[1],\"4\":[1],\"5\":[7,12],\"6\":[1,24],\"7\":[1],\"8\":[1,34],\"9\":[1,20],\"10\":[1],\"11\":[1,14],\"12\":[1,30],\"13\":[1,72],\"14\":[1],\"15\":[1,3],\"16\":[1,10],\"17\":[1,32],\"18\":[1,20],\"19\":[1,11],\"20\":[1,3],\"21\":[1,109],\"22\":[1,69],\"23\":[1,131],\"24\":[1,49],\"25\":[1,62],\"26\":[4],\"27\":[2,6],\"28\":[2],\"29\":[1,10],\"30\":[2,49],\"31\":[1,11],\"32\":[1,37],\"33\":[1,32],\"34\":[3],\"35\":[1,8],\"36\":[1,61],\"37\":[2,62],\"38\":[2,2],\"39\":[2,6],\"40\":[3,74],\"41\":[3,30],\"42\":[2,6],\"43\":[4,74],\"44\":[3,27],\"45\":[3,59],\"46\":[2,24],\"47\":[4,37],\"48\":[3,49],\"49\":[3,16],\"50\":[2],\"51\":[1,26],\"52\":[1,84],\"53\":[1,16],\"54\":[2],\"55\":[1,34],\"56\":[1,34],\"57\":[1,65],\"58\":[3,2],\"59\":[2],\"60\":[1,24],\"61\":[1,104],\"62\":[2,6],\"63\":[2,69],\"64\":[2,7],\"65\":[1,52],\"66\":[1,41],\"67\":[1,68],\"68\":[3,66],\"69\":[4,30],\"70\":[2],\"71\":[2,33],\"72\":[2,19],\"73\":[2],\"74\":[1,18],\"75\":[1,28],\"76\":[2,52],\"77\":[3,159],\"78\":[1,3]},\"averageFieldLength\":[1.7215189873417722,34.23212389755851],\"storedFields\":{\"0\":{\"h\":\"首页\"},\"1\":{\"h\":\"关于本站\",\"t\":[\"TBD 😃\"]},\"2\":{\"h\":\"日常笔记\"},\"3\":{\"h\":\"读书笔记\"},\"4\":{\"h\":\"论文笔记\"},\"5\":{\"h\":\"[VLDB'21] SlimChain：On/Off-Chain协同的私有链\",\"t\":[\"《Scaling Blockchain Transactions through Off-Chain Storage and Parallel Processing》论文笔记\"]},\"6\":{\"h\":\"Introduction\",\"t\":[\"现有的区块链系统存在的问题：\",\"区块链节点存储和计算耦合： \",\"每个节点都需要保存完整的账本，都需要执行所有的交易导致节点的存储压力和计算压力增加；\",\"扩展性有限；\",\"由于能够处理如此大量数据的节点越来越少，网络变得更加中心化，从而破坏了系统的安全性和稳健性；\",\"区块链网络分片： \",\"治标不治本，每片内的节点仍然执行重复的计算和存储；\",\"会引入跨分片交易处理问题以及额外的安全问题；\",\"本文提出了无状态区块链SlimChain，其主要特点包括：\",\"最小化区块节点的负担：区块节点设为无状态，区块相关数据存放在单独的存储节点；\",\"最大化系统吞吐量：支持交易在不同节点并行执行；\",\"支持高效分片：利用分片提高区块链交易处理的扩展性；\",\"安全保证：充分的区块链安全保证机制。\"]},\"7\":{\"h\":\"Design\"},\"8\":{\"h\":\"整体架构\",\"t\":[\"SlimChain组件主要包括三个部分：\",\"客户端（client）：发起交易（智能合约）请求；\",\"共识节点（consensus node）：SlimChain的链上（on-chain）部分，通过共识协议维护一致的账本视图（ledger view），具体可分为两种类型： \",\"区块提议节点（block proposers，后文简称提议节点）：生成新区块（类似于矿工节点）；\",\"区块观察节点（block observers，后文简称参与节点）：验证新区块；\",\"存储节点（storage node）：SlimChain的链下（off-chain）部分，持久化存储账本和其他区块相关的数据，执行交易。\"]},\"9\":{\"h\":\"区块数据结构\",\"t\":[\"链上部分：\",\"Hprev_blk​：前一个区块的哈希；\",\"πcons​：共识相关的参数；\",\"Htx_root​：区块中所有交易的汇总哈希值；\",\"Htx​：单个交易tx的哈希值；\",\"Hstate_root​：当前区块交易Merkle树的根节点；\",\"链下部分：\",\"Transactions：实际的交易执行内容；\",\"Merkle Trie：持久化保存的账本。\"]},\"10\":{\"h\":\"交易处理\"},\"11\":{\"h\":\"流程概述\",\"t\":[\"SlimChain中交易完整的流程如下：\",\"客户端向其中之一的存储节点发送交易请求<txinput​,σtx​>，包含交易的输入以及客户端的数字签名；\",\"存储节点收到后在本地执行（simulate）交易获取读集rtx​和写集wtx​，再执行完成后将执行结果以及证明πtx​广播给所有共识节点；\",\"共识节点验证执行结果后，生成区块并更新区块链的状态（修改区块高度等）；\",\"存储节点发现区块已经生成后，将事务的执行结果提交到底层账本中去。\"]},\"12\":{\"h\":\"存储节点交易执行流程\",\"t\":[\"存储节点的执行过程在TEE（trusted exection environment）中完成。\",\"在TEE中会执行流程包括：\",\"验证客户端发送的交易签名（L1）；\",\"基于前一个链下状态Hold​执行交易并获取读写集（L2）；\",\"验证从Hold​中读取结果的正确性（L3-4）；\",\"对读写集进行签名（L5）。\",\"离开了TEE之后，还会交易的写集{w}tx​创建一个额外的Merkle证明∗πwrite​∗留在后面使用。所以交易执行得到的结果就是下面这样，左边是当前新创建的链下状态（Hold​指的是H99​），在TEE中的执行结果不会立刻写回链下的状态。\",\"最后存储节点会将交易txnsubmit​=<txinput​,{r}tx,{w}tx,Hold​,πTEE​,πwrite​>打包并广播给所有的共识节点。\"]},\"13\":{\"h\":\"共识节点交易提交流程\",\"t\":[\"算法中一些符号的含义：\",\"Mi↦r/w​[k]：区块k中的读集/写集；\",\"Mr/w↦i​[k]：读/写过记录k的区块集合；\",\"Tw​：根据窗口内区块写集构建的不完全状态（完全状态的子集，完全状态保存在存储节点中，二者的根节点一致）。\",\"存储节点和共识节点均维护有一个相同结构的状态树，其高度为i的区块的根节点分别记为HSi​和HCi​，相同高度的哈希值是一致的并且HCi​只是HSi​中的一个子树。但是由于网络异步问题，同一交易发送到共识节点时其区块的高度要大于其在存储节点执行时区块的高度，举个例子交易txn在存储节点上执行时HS的高度为99，但是在执行节点生成区块时HC的高度为101。为了保证交易的及时处理（避免长时间无响应），同时考虑到二者高度差值越大可能出现冲突的概率就越大，所以需要加上时间窗口限制，这里的窗口大小设置为k。\",\"提议节点通过共识协议保证交易接受顺序的一致性。提议节点收到来自存储节点的交易后会按照顺序依次对事务做以下验证：\",\"检查是否在窗口内，签名验证是否通过，事务读写集是否满足序列化（L4-7）；\",\"使用写集{w}tx​*对应的写验证πwrite​*树插入到Tw​中（还没有计算新的根节点的值）（L8）；\",\"更新相应的映射集合Mi↦r/w​和Mr/w↦i​[k]（L9-12）；\",\"重新计算Tw​的根节点值Hstate_root​，并生成新的区块（L13）；\",\"滑动窗口（L14-23）。\",\"将写集中每一项对应的πwrite​合并至Tw​以及根据映射集合删除失效路径（窗口外区块）的算法分别如上所示，这里不过多介绍。\",\"对交易的可序列化检查算法如上所示，支持OCC和SSI两种经典并发控制算法，并未做优化所以这里也略过。\",\"这里提供了提议节点完成的执行流程的例子，如上图所示。交易tx1​−tx4​都可以正常提交，而交易tx5​因不满足SSI而退出。\",\"提议节点会将生成的区块同步给观察节点和存储节点。存储节点收到区块后会按照交易的顺序将其写集提交至底层账本，并且会保存交易的相关信息（例如交易的输入参数，读写集等）和上一个区块的快照Hold​而不是摘要。而观察节点在收到提议节点发送的区块之后会根据Algo2对区块的交易进行验证，然后加入到本地的区块链中。\"]},\"14\":{\"h\":\"MiniLSM源码阅读\"},\"15\":{\"h\":\"MiniLSM概览\",\"t\":[\"MiniLSM源码阅读笔记（一）\"]},\"16\":{\"h\":\"背景\",\"t\":[\"迟sir的教学性质的LSM+Rust项目：\",\"项目链接：https://github.com/skyzh/mini-lsm\",\"教程文档：https://skyzh.github.io/mini-lsm\"]},\"17\":{\"h\":\"总体架构\",\"t\":[\"LSM存储引擎一般包括三个部分：\",\"wal(write-ahead log)：预写日志文件；\",\"sstable(static string table)：磁盘中分层有序key-value对文件；\",\"memtable/immutable memtable(后文简称immutable)：内存中有序key-value对结构。\",\"存储引擎一般会提供一下接口：\",\"Put(key, value)：数据添加或修改；\",\"Delete(key)：数据删除；\",\"Get(key)：数据单点查询；\",\"Scan(range)：数据范围查询；\",\"Txn()：事务操作。\"]},\"18\":{\"h\":\"写流程\",\"t\":[\"写操作主要包括以下四步：\",\"预写日志，将修改保存至key-value对保存至磁盘中的wal中；\",\"将key-value写入memtable，到这一步用户线程操作结束；\",\"（后台flush线程）当mem-table满了之后将其冻结成immutable mem-table，然后写入磁盘中的SST中；\",\"（后台compact线程）当某一层SST满了之后进行压缩合并至下一层的sstable，以保持LSM-Tree的数据结构。\",\"写操作包括修改和删除操作，其中删除操作实际上就是value为空的修改操作。\"]},\"19\":{\"h\":\"读流程\",\"t\":[\"读操作主要包括以下两步：\",\"按照从新到旧的顺序在memtable/immutable中检索；\",\"没找到的话会在磁盘中LSM-Tree的每一层sstable进行检索。\",\"查询操作包括单点查询和范围查询，范围查询的关键是通过单点查询获取其起始边界的位置，然后再该起始点顺序访问。\",\"上述流程只是简单的概括介绍，由于使用了多版本机制实际的读写流程要复杂一些。\"]},\"20\":{\"h\":\"MiniLSM基本组件\",\"t\":[\"MiniLSM源码阅读笔记（二）\"]},\"21\":{\"h\":\"LSM\",\"t\":[\"LsmStorageOptions主要保存lsm相关的配置信息。\",\"pub struct LsmStorageOptions { // block大小，字节为单位 pub block_size: usize, // sstable大小，以字节为单位 pub target_sst_size: usize, // 内存中最大的memtable数量 pub num_memtable_limit: usize, // compaction选项 pub compaction_options: CompactionOptions, // 是否开启wal pub enable_wal: bool, // 是否可序列化 pub serializable: bool, }\",\"LsmStorageState维护存储的核心组件状态，包括memtable、sstable的状态。\",\"pub struct LsmStorageState { // 当前的可修改的memtable pub memtable: Arc<MemTable>, // 不可修改的memtable列表，按顺序存储 pub imm_memtables: Vec<Arc<MemTable>>, // 不可修改的memtable列表持久化成sstable的l0层，按顺序存储 pub l0_sstables: Vec<usize>, // 保存每一层对应的sstable id列表 pub levels: Vec<(usize, Vec<usize>)>, // 保存每个sstable id对应的sstable对象 pub sstables: HashMap<usize, Arc<SsTable>>, }\",\"LsmStorageInner包含存储状态以及lsm的配置信息，主要负责对存储状态的修改（压实、事务处理等）。\",\"pub(crate) struct LsmStorageInner { // lsm状态，加读写锁进行并发控制 pub(crate) state: Arc<RwLock<Arc<LsmStorageState>>>, // lsm全局锁 pub(crate) state_lock: Mutex<()>, // sstable路径 path: PathBuf, // 内存中的block缓存 pub(crate) block_cache: Arc<BlockCache>, // 下一个sstable的id next_sst_id: AtomicUsize, // lsm选项 pub(crate) options: Arc<LsmStorageOptions>, // compaction相关 pub(crate) compaction_controller: CompactionController, // manifest相关 pub(crate) manifest: Option<Manifest>, // mvcc相关 pub(crate) mvcc: Option<LsmMvccInner>, // compaction过滤器 pub(crate) compaction_filters: Arc<Mutex<Vec<CompactionFilter>>>, }\",\"MiniLsm为顶层封装结构体，主要为上层提供操作接口。\",\"pub struct MiniLsm { // lsm tree对象 pub(crate) inner: Arc<LsmStorageInner>, // 通知flush线程停止 flush_notifier: crossbeam_channel::Sender<()>, // flush线程 flush_thread: Mutex<Option<std::thread::JoinHandle<()>>>, // 通知compaction线程停止 compaction_notifier: crossbeam_channel::Sender<()>, // compaction线程 compaction_thread: Mutex<Option<std::thread::JoinHandle<()>>>, }\"]},\"22\":{\"h\":\"MemTable\",\"t\":[\"memtable是LSM的在内存中的组件，实现结构为线程安全的跳表，主要提供高效的数据检索和修改。\",\"memtable分为两种：可修改的mutable和不可修改的immutable，mutable在任意时刻只能有一个，而immutable则可以有多个。当mutable的大小达到上限后会被冻结为immutable，等待被持久化为sstable文件。\",\"pub struct MemTable { // 线程安全跳表 pub(crate) map: Arc<SkipMap<KeyBytes, Bytes>>, // wal对象，用来持久化保存memtable修改日志 wal: Option<Wal>, // 跳表id id: usize, // 跳表预估占用内存大小 approximate_size: Arc<AtomicUsize>, }\",\"memtable提供了以下方法：\",\"// 构造函数：创建带有wal的memtable，path是wal的文件路径 // 注意wal和memtable是一对一的 fn create_with_wal(id: usize, path: impl AsRef<Path>) -> Result<Self> // 从wal文件中恢复memtable fn recover_from_wal(id: usize, path: impl AsRef<Path>) -> Result<Self> // 获取key对应的值 fn get(&self, key: KeySlice) -> Option<Bytes> // 修改key对应的值为value fn put(&self, key: KeySlice, value: &[u8]) -> Result<()> // 范围检索，生成带有边界的iterator fn scan(&self, lower: Bound<KeySlice>, upper: Bound<KeySlice>) -> MemTableIterator // 将wal落盘 fn sync_wal(&self) -> Result<()> // 将immutable转换为sstable文件 fn flush(&self, builder: &mut SsTableBuilder) -> Result<()>\"]},\"23\":{\"h\":\"SSTable\",\"t\":[\"sstable是LSM在磁盘中的核心数据结构。LSM在磁盘中是典型的分层结构：每一层都是由若干sstable组成，sstable是由block及其索引组成，而block是由若干key-value对及其索引组成。\",\"sstable的结构：\",\"------------------------------------------------------------------------------------------- | Block Section | Meta Section | Extra | ------------------------------------------------------------------------------------------- | data block | ... | data block | metadata | meta block offset (u32) | -------------------------------------------------------------------------------------------\",\"其中Block Section包含的是具体的block数据；Meta Section则是每个block的元数据，可以视为block的索引；Extra部分保存的是Meta Section的偏移值。\",\"data block的结构：\",\"---------------------------------------------------------------------------------------------------- | Data Section | Offset Section | Extra | ---------------------------------------------------------------------------------------------------- | Entry #1 | Entry #2 | ... | Entry #N | Offset #1 | Offset #2 | ... | Offset #N | num_of_elements | ----------------------------------------------------------------------------------------------------\",\"其中Data Section包含的是具体的key-value键值对，Offset Section中则是每个key-value的偏移值，可以视为key-value的索引；Extra部分则保存了block中key-value对的个数。\",\"key-value键值对的结构：\",\"--------------------------------------------------------------------------- | Entry #1 | ... | --------------------------------------------------------------------------- | key_len (2B) | key (key_len) | value_len (2B) | value (value_len) | ... | ---------------------------------------------------------------------------\",\"上述结构都只介绍了核心的组件，实际上还有一些附加的信息，具体来看各个部分结构体的定义。\",\"block的结构体：\",\"pub struct Block { // 序列化后的data section pub(crate) data: Vec<u8>, // 序列化后的offset section pub(crate) offsets: Vec<u16>, }\",\"block相关的方法：\",\"// 将整个block对象序列化为字节数组 fn encode(&self) -> Bytes // 从字节数组反序列化得到block对象 fn decode(data: &[u8]) -> Self\",\"blockmeta保存的是对应block的元数据信息，其结构体定义：\",\"pub struct BlockMeta { // block的在sstable中的偏移 pub offset: usize, // block中的第一个key（最小的key） pub first_key: KeyBytes, // block中的最后一个key（最大的key） pub last_key: KeyBytes, }\",\"blockmeta相关的方法：\",\"// 将blockmeta数组序列化成字节数组 fn encode_block_meta(block_meta: &[BlockMeta], max_ts: u64, buf: &mut Vec<u8>) // 将Meta Section字节数组反序列化成blockmeta数组 fn decode_block_meta(mut buf: &[u8]) -> Result<(Vec<BlockMeta>, u64)>\",\"sstable的结构体：\",\"pub struct SsTable { // sstable对应的磁盘中的文件 pub(crate) file: FileObject, // meta section对应的block的元数据列表 pub(crate) block_meta: Vec<BlockMeta>, // meta section的偏移值 pub(crate) block_meta_offset: usize, // sstable id id: usize, // 内存中缓存的block，用来快速检索block block_cache: Option<Arc<BlockCache>>, // sstable中的最小key，起始位置 first_key: KeyBytes, // sstable中的最大key，末尾位置 last_key: KeyBytes, // bloom过滤器，用来快速检索key是否存在 pub(crate) bloom: Option<Bloom>, // sstable中最后一次修改的时间戳 max_ts: u64, }\",\"sstable相关的方法：\",\"// 构造函数：打开ssatble文件，初始化sstable对象 fn open(id: usize, block_cache: Option<Arc<BlockCache>>, file: FileObject) -> Result<Self> // 根据block索引从block cache或者sstable中读取对应的block fn read_block(&self, block_idx: usize) -> Result<Arc<Block>> // 查找key所在的block索引 fn find_block_idx(&self, key: KeySlice) -> usize\"]},\"24\":{\"h\":\"WAL\",\"t\":[\"wal（write-ahead-log）用来持久化保存对LSM的修改日志，每一次操作都会先被记录并持久化到wal中，之后才会被提交到LSM结构修改，这样保证存储引擎宕机时不会发生数据的丢失。wal的日志持久化格式为：\",\"------------------------------------------------------------------------------------------------------------ | WAL Record #1 | ... | ------------------------------------------------------------------------------------------------------------ | key_len (2B) | key (key_len) | timestamp (8B) | value_len (2B) | value (value_len) | checksum (4B) | ... | ------------------------------------------------------------------------------------------------------------\",\"wal的结构体：\",\"pub struct Wal { // 持久化的日志文件 file: Arc<Mutex<BufWriter<File>>>, }\",\"wal相关方法：\",\"// 构造函数：创建wal文件 fn create(path: impl AsRef<Path>) -> Result<Self> // 根据wal日志恢复memtable fn recover(path: impl AsRef<Path>, skiplist: &SkipMap<KeyBytes, Bytes>) -> Result<Self> // 向wal日志中添加修改记录 fn put(&self, key: KeySlice, value: &[u8]) -> Result<()>\"]},\"25\":{\"h\":\"Manifest\",\"t\":[\"manifest记录LSM在内存中的数据（memtable、compaction任务等）与持久化后的文件的对应关系，通常用json格式保存，以便在系统重启的时候能够恢复到正常的状态。\",\"manifest的结构体：\",\"pub struct Manifest { // manifest文件 file: Arc<Mutex<File>>, } // manifest保存的内存数据类型 // 每种类型都包含一个json对象 pub enum ManifestRecord { // level0层所有的sstable id Flush(usize), // 创建过的所有memtable id NewMemtable(usize), // 执行过compaction的所有sstable id Compaction(CompactionTask, Vec<usize>), }\",\"manifest的存储格式如下，其中slice保存的是序列化后的json对象\",\"-------------------------------------------------------------- | Manifest Record #1 | ... | -------------------------------------------------------------- | len (8B) | serialized json obj (len) | checksum (4B) | ... | --------------------------------------------------------------\",\"manifest相关方法：\",\"// 构造函数，创建一个新的manifest文件 fn create(path: impl AsRef<Path>) -> Result<Self> // 从manifest文件中恢复得到ManifestRecord列表 fn recover(path: impl AsRef<Path>) -> Result<(Self, Vec<ManifestRecord>)> // 向manifest文件中添加一条ManifestRecord fn add_record(&self, _state_lock_observer: &MutexGuard<()>, record: ManifestRecord) -> Result<()>\"]},\"26\":{\"h\":\"《Effective Modern C++》\"},\"27\":{\"h\":\"第一章：型别推导\",\"t\":[\"《Effective Modern C++》阅读笔记（一）\"]},\"28\":{\"h\":\"条款1：理解模板型别推导\"},\"29\":{\"h\":\"函数模板形式\",\"t\":[\"// 声明形式 template<typename T> void f(ParamType param); // 调用形式 f(expr);\"]},\"30\":{\"h\":\"为指针或者引用，而非万能引用\",\"t\":[\"函数的形式如下：\",\"template<typename T> void f(T& param); // param是一个引用\",\"类型推导会这样进行：\",\"如果expr的类型是一个引用，忽略引用部分，保留const/volatile属性；\",\"然后expr的类型与ParamType进行模式匹配来决定T。\",\"这里举个例子：\",\"// 变量定义 int x=27; // x是int const int cx=x; // cx是const int const int& rx=x; // rx是指向作为const int的x的引用 // 函数调用 f(x); // T是int，param的类型是int& f(cx); // T是const int，param的类型是const int& f(rx); // T是const int，param的类型是const int&\",\"如果ParamType带有const/volatile属性，则推导过程与上述过程类似：\",\"template<typename T> void f(const T& param); // param现在是reference-to-constint x = 27; // 如之前一样 const int cx = x; // 如之前一样 const int& rx = x; // 如之前一样 f(x); // T是int，param的类型是const int& f(cx); // T是int，param的类型是const int& f(rx); // T是int，param的类型是const int&\",\"如果param是一个指针，推导过程也是类似：\",\"template<typename T> void f(T* param); // param现在是指针 int x = 27; // 同之前一样 const int *px = &x; // px是指向作为const int的x的指针 f(&x); // T是int，param的类型是int* f(px); // T是const int，param的类型是const int*\"]},\"31\":{\"h\":\"为万能引用\",\"t\":[\"函数的形式如下：\",\"template<typename T> void f(const T& param); // param现在是reference-to-const\",\"推导过程参考引用折叠\"]},\"32\":{\"h\":\"既非指针也非引用\",\"t\":[\"函数的形式如下：\",\"template<typename T> void f(T param); // 以传值的方式处理param\",\"类型推导会去除传入参数的所有属性，只保留值类型：\",\"int x=27; // 如之前一样 const int cx=x; // 如之前一样 const int & rx=cx; // 如之前一样 f(x); // T和param的类型都是int f(cx); // T和param的类型都是int f(rx); // T和param的类型都是int\",\"如果传入的是一个指针，则会去掉指针本身的const/volatile属性，保留指针指向对象的const/volatile属性：\",\"template<typename T> void f(T param); // 仍然以传值的方式处理param const char* const ptr = // ptr是一个常量指针，指向常量对象 \\\"Fun with pointers\\\"; f(ptr); // 传递const char * const类型的实参 // T的类型为const char*\"]},\"33\":{\"h\":\"特殊情况\",\"t\":[\"对于函数形式为：\",\"template<typename T> void f1(T param); // 以传值的方式处理param template<typename T> void f2(T& param); // 以引用的方式处理param\",\"如果传入的是数组类型，则：\",\"const char name[] = \\\"J. P. Briggs\\\"; // name的类型是const char[13] f1(name); // T被推导为const char* f2(name); // T被推到为const char (&)[13]\",\"如果传入的是函数类型，则：\",\"void someFunc(int, double); // someFunc是一个函数， // 类型是void(int, double) f1(someFunc); // param被推导为指向函数的指针， // 类型是void(*)(int, double) f2(someFunc); // param被推导为指向函数的引用， // 类型是void(&)(int, double)\"]},\"34\":{\"h\":\"条款2：理解 类型推导\"},\"35\":{\"h\":\"型别推导\",\"t\":[\"auto的型别推导与模板推导规则基本一致：\",\"auto xx = var; // 值类型推导 auto& xx = var; // 引用类型推导 auto&& xx = var; // 引用折叠\"]},\"36\":{\"h\":\"初始化\",\"t\":[\"int x1 = 27; int x2(27); int x3 = { 27 }; int x4{ 27 }; // 以上将x1，x2，x3，x4初始化为27 auto x1 = 27; //类型是int，值是27 auto x2(27); //同上 auto x3 = { 27 }; //类型是std::initializer_list<int>，值是{ 27 } auto x4{ 27 }; //同上 auto x5 = { 1, 2, 3.0 }; //错误！无法推导std::initializer_list<T>中的T\",\"对于大括号初始化表达式的处理方式，是auto型别推导和模板型别推导唯一不同之处：\",\"auto x = { 11, 23, 9 }; // x的类型是std::initializer_list<int> template<typename T> // 带有与x的声明等价的 void f(T param); // 形参声明的模板 f({ 11, 23, 9 }); // 错误！不能推导出T template<typename T> void f(std::initializer_list<T> initList); f({ 11, 23, 9 }); // T被推导为int，initList的类型为 // std::initializer_list<int>\",\"C++14允许auto用于函数返回值并会被推导，而且C++14的lambda函数也允许在形参声明中使用auto。但是在这些情况下auto实际上使用模板类型推导的那一套规则在工作，而不是auto类型推导，所以说下面这样的代码不会通过编译：\",\"auto createInitList() { return { 1, 2, 3 }; // 错误！不能推导{ 1, 2, 3 }的类型 } std::vector<int> v; auto resetV = [&v](const auto& newValue){ v = newValue; }; //C++14 resetV({ 1, 2, 3 }); // 错误！不能推导{ 1, 2, 3 }的类型\"]},\"37\":{\"h\":\"条款3：理解decltype\",\"t\":[\"decltype在推导时会保留完整类型，注意如果推导传入的是右值则会去掉引用转换为常量值，例如：\",\"const int i = 0; // decltype(i)是const int bool f(const Widget& w); // decltype(w)是const Widget& // decltype(f)是bool(const Widget&) struct Point{ int x,y; // decltype(Point::x)是int }; // decltype(Point::y)是int Widget w; // decltype(w)是Widget if (f(w))… // decltype(f(w))是bool，去掉右值的引用部分 template<typename T> // std::vector的简化版本 class vector{ public: T& operator[](std::size_t index); }; vector<int> v; // decltype(v)是vector<int> if (v[0] == 0)… // decltype(v[0])是int&\",\"decltype(auto)是一种特殊的用法，常用作返回值类型推导，用来保留完整的返回值类型：\",\"decltype(auto) foo() { int x = 42; return x; // 返回 int } decltype(auto) bar() { int x = 42; return (x); // 返回 int& } decltype(auto) bar(vector<int>& arr) { return arr[0]; // 返回 int& } // 等效于 auto& bar(vector<int>& arr) { return arr[0]; // 返回 int& } // 注意decltype(auto)可以接收任意类型的返回值，但是auto&只能接收非右值类型的返回值 Widget w; const Widget& cw = w; auto myWidget1 = cw; //auto类型推导 //myWidget1的类型为Widget decltype(auto) myWidget2 = cw; //decltype类型推导 //myWidget2的类型是const Widget&\"]},\"38\":{\"h\":\"条款4：掌握查看型别推导结果的方法\",\"t\":[\"略。。。\"]},\"39\":{\"h\":\"第二章：auto\",\"t\":[\"《Effective Modern C++》阅读笔记（二）\"]},\"40\":{\"h\":\"条款5：优先考虑 而非显式声明\",\"t\":[\"auto可以简化变量声明，例如：\",\"template<typename It> void dwim(It b,It e) { while (b != e) { auto currValue = *b; // currValue的类型为std::iterator_traits<It>::value_type … } }\",\"再例如：\",\"auto sz =v.size(); // sz的类型是std::vector<int>::size_type\",\"auto甚至能表示一些只有编译器才知道的类型：\",\"auto derefUPLess = [](const std::unique_ptr<Widget> &p1, //用于std::unique_ptr const std::unique_ptr<Widget> &p2) //指向的Widget类型的 { return *p1 < *p2; }; //比较函数\",\"如果使用C++14可以进一步简化为：\",\"auto derefLess = //C++14版本 [](const auto& p1, //被任何像指针一样的东西 const auto& p2) //指向的值的比较函数 { return *p1 < *p2; };\",\"这里面derefLess变量的类型是一个不可命名的，匿名函数对象类型，只有编译器可见。\",\"当然这里的闭包可以用std::function来实现：\",\"std::function<bool(const std::unique_ptr<Widget> &, const std::unique_ptr<Widget> &)> derefUPLess = [](const std::unique_ptr<Widget> &p1, const std::unique_ptr<Widget> &p2) { return *p1 < *p2; };\",\"但是这样一方面会造成代码冗长，同时也会带来额外的内存空间消耗（std::function对象本身占用空间）。\",\"auto的使用还可能避免可能的额外的内存复制开销。例如遍历一个哈希表m，如果不使用auto可能会写成如下：\",\"std::unordered_map<std::string, int> m; … for(const std::pair<std::string, int>& p : m) { … //用p做一些事 }\",\"但是实际上m中每个元素的类型为std::pair<const std::string, int>，如果按照上述的写法则会发生std::pair<const std::string, int>到std::pair<std::string, int>的隐式转换导致的复制，另外如果在遍历时使用了p的内存地址，则这个地址是指向复制后的临时变量，如果在该临时变量析构后访问可能会导致潜在的内存错误。\"]},\"41\":{\"h\":\"条款6：如果auto推导不符合预期，使用显式型别初始化\",\"t\":[\"auto在一些场景下使用可能会导致潜在的风险，例如：\",\"std::vector<bool> features(const Widget& w); // 这个是函数 Widget w; … auto highPriority = features(w)[5]; … processWidget(w, highPriority); // 未定义行为！\",\"上例中highPriority变量的类型为std::vector<bool>::reference，std::vector<bool>::reference相对于其他的std::vector<T>::reference比较特殊，其引用的是该元素所在的字对象，例如本例中features(w)[5]返回的是函数features返回值创建的临时std::vector<bool>对象中第五个bit所在字的引用，而highPriority也是指向该临时对象的引用，但是此时该临时变量已经析构，所以会导致未定义的行为。\",\"这里应该进行显式转换：\",\"std::vector<bool> features(const Widget& w); // 这个是函数 Widget w; … bool highPriority = features(w)[5]; … processWidget(w, highPriority);\"]},\"42\":{\"h\":\"第三章：转向现代C++\",\"t\":[\"《Effective Modern C++》阅读笔记（三）\"]},\"43\":{\"h\":\"条款7：区别使用()和{}创建对象\",\"t\":[\"c++初始化的方式比较多样，包括圆括号（()）初始化、等号（=）初始化和大括号（{}）初始化：\",\"int x(0); // 使用圆括号初始化 int y = 0; // 使用\\\"=\\\"初始化 int z{ 0 }; // 使用花括号初始化 int z = {0}; // 使用\\\"=\\\"和花括号\",\"这种多样性可能会导致一些误解，对此C++11引入了统一的初始化形式—基于大括号的初始化形式。大括号初始化的默认类型为std::initializer_list：\",\"auto var = {1, 2, 3}; // 则decltype(var)为std::initializer_list\",\"使用大括号初始化常规变量：\",\"std::vector<int> v{ 1, 3, 5 }; // v初始内容为1,3,5\",\"使用大括号初始化非静态成员默认值：\",\"class Widget{ private: int x{ 0 }; // 没问题，x初始值为0 int y = 0; // 也可以 int z(0); // 错误！ }\",\"使用大括号初始化不可复制类的对象：\",\"std::atomic<int> ai1{ 0 }; // 没问题 std::atomic<int> ai2(0); // 没问题 std::atomic<int> ai3 = 0; // 错误！\",\"大括号初始化可以解决小括号初始化存在的种种问题。\",\"问题1：小括号初始化可能会因为C++的解析语法被视为函数声明，例如：\",\"Widget w1(10); // 使用实参10调用Widget的一个构造函数 Widget w2(); // 最令人头疼的解析！声明一个函数w2，返回Widget\",\"使用大括号则没上述问题：\",\"Widget w3{}; // 调用没有参数的构造函数构造对象\",\"问题2：小括号初始化可能会无法实现预期的构造函数，例如想要创建一个包含10和20两个数的vector容器，如果使用小括号：\",\"std::vector<int> v1(10, 20); // 创建一个包含10个元素的std::vector，所有的元素的值都是20\",\"如果使用大括号：\",\"std::vector<int> v2{10, 20}; // 创建包含两个元素的std::vector，元素的值为10和20\"]},\"44\":{\"h\":\"条款8：优先考虑使用 而不是0和\",\"t\":[\"NULL和nullptr最大的区别是NULL的类型是int，即NULL=0；而nullptr的类型是std::nullptr_t，本质是一个指针类型。nullptr可以隐式转换成普通指针（type*）和只能指针（std::shared_ptr<type>）类型，而NULL只能转换成普通指针。\",\"void f(int); // 三个f的重载函数 void f(bool); void f(void*); f(0); // 调用f(int)而不是f(void*) f(NULL); // 可能不会被编译，一般来说调用f(int)， // 绝对不会调用f(void*)\"]},\"45\":{\"h\":\"条款9：有限考虑使用 声明别名而不是\",\"t\":[\"大部分场景下typedef和using用法类似：\",\"// 使用typedef声明类别名 typedef std::unique_ptr<std::unordered_map<std::string, std::string>> UPtrMapSS; // 使用using声明类别名 using UPtrMapSS = std::unique_ptr<std::unordered_map<std::string, std::string>>; // 使用typedef声明函数别名 typedef void (*FP)(int, const std::string&); // 使用using声明函数别名 using FP = void (*)(int, const std::string&);\",\"但是如果要声明类中的嵌套类型，using会比typedef要方便许多。例如容器类MyAllocList中定义了分配器的类型type：\",\"template<typename T> // MyAllocList<T>是 struct MyAllocList { // std::list<T, MyAlloc<T>> typedef std::list<T, MyAlloc<T>> type; // 的同义词 }; template<typename T> class Widget { // Widget<T>含有一个 private: // MyAllocLIst<T>对象 typename MyAllocList<T>::type list; // 作为数据成员 … // 这里使用typename主要是因为 // 声明type为类型而不是一个成员变量 };\",\"而如果使用using则会简化很多：\",\"template<typename T> using MyAllocList = std::list<T, MyAlloc<T>>; // 同之前一样 template<typename T> class Widget { private: MyAllocList<T> list; // 没有“typename” … // 没有“::type” };\",\"C++中一些特殊的特征类型：\",\"std::remove_const<T>::type // C++11: const T → T std::remove_const_t<T> // C++14 等价形式 std::remove_reference<T>::type // C++11: T&/T&& → T std::remove_reference_t<T> // C++14 等价形式 std::add_lvalue_reference<T>::type // C++11: T → T& std::add_lvalue_reference_t<T> // C++14 等价形式\"]},\"46\":{\"h\":\"条款10：优先考虑使用限定域的枚举而不是非限定域的枚举\",\"t\":[\"非限定域枚举可能存在的问题：\",\"enum Color { black, white, red }; // black, white, red在Color所在的作用域 auto white = false; // 错误! white早已在这个作用中声明\",\"应改为限定域（也称枚举类）来实现：\",\"enum class Color { black, white, red }; // black, white, red限制在Color域内 auto white = false; // 没问题，域内没有其他“white” Color c = white; // 错误，域中没有枚举名叫white Color c = Color::white; // 没问题 auto c = Color::white; // 也没问题（也符合Item5的建议）\"]},\"47\":{\"h\":\"条款11：优先考虑使用 而不是 未定义函数\",\"t\":[\"如果想让普通函数不接受某些类别的形参进行隐式转换或者模板函数的某种实例化函数被调用，可以采用delete关键字：\",\"bool isLucky(int number); // 原始版本 bool isLucky(char) = delete; // 拒绝char bool isLucky(bool) = delete; // 拒绝bool bool isLucky(double) = delete; // 拒绝float和double if (isLucky('a')) … // 错误！调用deleted函数 if (isLucky(true)) … // 错误！ if (isLucky(3.5f)) … // 错误！ template<typename T> void processPointer(T* ptr); template<> void processPointer<void>(void*) = delete; // 拒绝void* template<> void processPointer<char>(char*) = delete; // 拒绝char* template<> void processPointer<const void>(const void*) = delete; // 拒绝const void* template<> void processPointer<const char>(const char*) = delete; // 拒绝const char*\"]},\"48\":{\"h\":\"条款12：使用 声明重载函数\",\"t\":[\"派生类重写（override）基类函数需要满足以下条件：\",\"基类函数必须是virtual（派生类则不一定需要是虚函数）；\",\"基类和派生类函数名必须完全一样（除非是析构函数)；\",\"基类和派生类函数形参类型必须完全一样；\",\"基类和派生类函数常量性const必须完全一样；\",\"基类和派生类函数的返回值和异常说明必须兼容。\",\"class Base { public: virtual void doWork(); // 基类虚函数 … }; class Derived: public Base { public: virtual void doWork(); // 重写Base::doWork … // （这里“virtual”是可以省略的） }; std::unique_ptr<Base> upb = // 创建基类指针指向派生类对象 std::make_unique<Derived>(); upb->doWork(); // 通过基类指针调用doWork， // 实际上是派生类的doWork函数被调用\",\"引用限定符是C++11引入的特性，其可以在成员参数列表之后来指定this对象的左值与右值属性：\",\"若引用限定符为&,则表明this对象指向着左值对象；\",\"若引用限定符为&&,则表明this对象指向着右值对象。\",\"举个例子：\",\"struct X { void foo() &; void foo() &&; }; X x; x.foo(); // 调用 foo1() X().foo(); // 调用 foo2() struct X { void foo() && {} }; X x; x.foo(); // 报错 struct X { void foo() & {} }; X().foo(); // 报错\",\"引用限定符的用法于const限定类似，const放在成员函数参数列表之后来指定this对象的const属性。\"]},\"49\":{\"h\":\"条款13：优先考虑 而非\",\"t\":[\"优先使用const类型的iterator：\",\"std::vector<int> values; auto it = // 使用cbegin std::find(values.cbegin(), values.cend(), 1983); // 和cend values.insert(it, 1998);\"]},\"50\":{\"h\":\"条款14：只要函数不抛出异常请使用\"},\"51\":{\"h\":\"C++异常处理流程\",\"t\":[\"c++程序在执行过程中，出现异常后具体的处理流程如下：\",\"**异常或错误发生：**例如除零错误、内存访问错误或其他错误，程序会抛出一个异常。\",\"**调用栈解开（stack unwinding）：**程序会逐层返回到调用栈中的函数，不能处理异常的函数会直接退出。\",\"**返回到调用函数：**当程序找到可以处理异常的函数func时，程序会将控制权返回到该函数，并执行func的异常处理代码。\",\"**程序继续执行：**如果异常被成功处理，程序会继续执行func的后续逻辑。如果异常没有被处理，程序会调用std::terminate()中止程序。\",\"为了能正确处理异常，程序在任何时间都要维护完整的调用栈，这会占用一定的空间同时也会屏蔽部分优化。\"]},\"52\":{\"h\":\"为什么要加上\",\"t\":[\"对于一些不会产生异常的函数来说，加上noexcept主要有两方面的原因：\",\"让编译器生成更好的目标代码\",\"首先对比C++98和C++11在声明函数不会抛出异常的写法：\",\"int f(int x) throw(); //C++98风格，没有来自f的异常 int f(int x) noexcept; //C++11风格，没有来自f的异常\",\"如果在运行时f出现异常，在C++98中调用栈会解开至f的调用方，然后执行一些与本条款无关的操作后中止，可能会导致未定义的行为（undefined behavior）；而C++11中并没有要求此时f的调用栈是可解开的，也不要求在抛出异常后调用栈中函数内部变量析构时的顺序，因此可以提供了更多的优化机会，同时标准库会调用std::terminate()来中止程序不会出现程序未定义的情况。\",\"RetType function(params) noexcept; //极尽所能优化 RetType function(params) throw(); //较少优化 RetType function(params); //较少优化\",\"这里举个例子：\",\"std::vector<Widget> vw; … Widget w; … //用w做点事 vw.push_back(w); //把w添加进vw\",\"对于push_back的操作一种显然的优化思路是将复制操作改为移动操作，但是如果执行push_back的过程中抛出异常（例如由于Widget类移动构造函数造成的），则使用移动操作可能会出现问题：部分元素已被移出，而剩下的还在远处，进而导致安全问题。\",\"对此如果使用throw()标记会避免进行移动操作，但是这样对于移动操作不会产生异常的类来说性能上还有很大的提升空间。由此使用noexcept便能很好地解决这一问题：只需要检查该类的移动操作是否标记为noexcept即可。\",\"作为一元操作符提供更好的灵活性\",\"swap函数是noexcept的另一个绝佳用地。swap是STL算法实现的一个关键组件，它也常用于拷贝运算符重载中，标准库的swap是否noexcept有时依赖于用户定义的swap是否noexcept。比如，数组和std::pair的swap声明如下：\",\"template <class T, size_t N> void swap(T (&a)[N], // 表示a为一个拥有N个T类型数组的引用 T (&b)[N]) noexcept(noexcept(swap(*a, *b))); //见下文 template <class T1, class T2> struct pair { … void swap(pair& p) noexcept(noexcept(swap(first, p.first)) && noexcept(swap(second, p.second))); … };\",\"此时pair中的swap是否被标记为noexcept取决于T1和T2中的swap函数是否被标记为except。\"]},\"53\":{\"h\":\"相关注意事项\",\"t\":[\"大多数函数都是异常中立（exception-netural）的，这类函数自身不抛出异常，但是它们调用的函数可能会抛出异常，因此不适合被标记为noexception。\",\"默认的内存释放函数（即delete和delete[]）和析构函数都会被隐式地标记为noexcept，如果需要声明为可能抛出异常，需要加上noexcept(false)。\",\"标记为noexcept的函数调用没有标记为noexcept的函数时可以通过编译，但是不推荐这么做。\"]},\"54\":{\"h\":\"条款15：尽可能地使用\"},\"55\":{\"h\":\"修饰变量\",\"t\":[\"constexpr修饰的变量一定是编译时已知的，所有的constexpr变量都是const变量，但是const变量不一定是constexpr变量：\",\"int sz; //non-constexpr变量 … constexpr auto arraySize1 = sz; //错误！sz的值在 //编译期不可知 std::array<int, sz> data1; //错误！一样的问题 constexpr auto arraySize2 = 10; //没问题，10是 //编译期可知常量 std::array<int, arraySize2> data2; //没问题, arraySize2是constexpr int sz; //和之前一样 … const auto arraySize = sz; //没问题，arraySize是sz的const复制 std::array<int, arraySize> data; //错误，arraySize值在编译期不可知\"]},\"56\":{\"h\":\"修饰函数\",\"t\":[\"使用constexpr修饰函数表示如果传入该函数的实参值都是编译期已知的（即字面值（literal type）），则其执行结果也是编译器已知的；否则如果存在一个或者多个实参是编译器未知的，则该函数退化为普通函数。举个例子：\",\"constexpr //pow是绝不抛异常的 int pow(int base, int exp) noexcept //constexpr函数 { … //实现在下面 } constexpr auto numConds = 5; //（上面例子中）条件的个数 std::array<int, pow(3, numConds)> results; //结果有3^numConds个元素\",\"从c++14开始，constexpr函数内也可以创建局部变量以及使用if/while/for语句等。\"]},\"57\":{\"h\":\"修饰自定义类对象\",\"t\":[\"自定义类的对象也可以是constexpr类别，只要其构造函数和其他成员函数都是constexpr修饰的。举个例子：\",\"class Point { public: constexpr Point(double xVal = 0, double yVal = 0) noexcept : x(xVal), y(yVal) {} constexpr double xValue() const noexcept { return x; } constexpr double yValue() const noexcept { return y; } void setX(double newX) noexcept { x = newX; } void setY(double newY) noexcept { y = newY; } private: double x, y; };\",\"Point的构造函数被声明为constexpr函数，因此其构造出来的对象在编译时也是已知的。可以进一步实现一个接收constexpr的Point对象，并返回constexpr类型结果的编译时函数，如下所示：\",\"constexpr Point midpoint(const Point& p1, const Point& p2) noexcept { return { (p1.xValue() + p2.xValue()) / 2, //调用constexpr (p1.yValue() + p2.yValue()) / 2 }; //成员函数 } constexpr auto mid = midpoint(p1, p2); //使用constexpr函数的结果 //初始化constexpr对象\",\"C++14以后甚至可以修改constexpr的对象成员变量，例如：\",\"//返回p相对于原点的镜像 constexpr Point reflection(const Point& p) noexcept { Point result; //创建non-const Point result.setX(-p.xValue()); //设定它的x和y值 result.setY(-p.yValue()); return result; //返回它的副本 } constexpr Point p1(9.4, 27.7); //和之前一样 constexpr Point p2(28.8, 5.3); constexpr auto mid = midpoint(p1, p2); constexpr auto reflectedMid = //reflectedMid的值 reflection(mid); //(-19.1, -16.5)在编译期可知\"]},\"58\":{\"h\":\"条款16：保证 成员地线程安全\",\"t\":[\"略。。。\"]},\"59\":{\"h\":\"条款17：理解特种函数的生成机制\"},\"60\":{\"h\":\"特种函数\",\"t\":[\"C++中的特种函数主要包括：\",\"默认构造函数；\",\"析构函数；\",\"复制构造函数；\",\"复制赋值函数；\",\"移动构造函数；\",\"移动赋值函数。\",\"在特定情境下如果用户没有显示声明特种函数，编译器会自动生成，生成的特种函数都是具有public访问层级且是inline、非虚的。\",\"class Widget { public: … Widget(Widget&& rhs); //移动构造函数 Widget& operator=(Widget&& rhs); //移动赋值运算符 … };\",\"自动生成的复制/移动构造函数会调用rhs中各个非静态成员的复制/移动构造函数。当然对于移动构造函数来说，如果非静态成员类别为不可移动类别（例如C++98的遗留类型），则会调用其复制构造函数。\"]},\"61\":{\"h\":\"生成机制\",\"t\":[\"默认构造函数\",\"仅当类中不包含用户声明的任何构造函数时才会生成。\",\"析构函数\",\"当类中不包含用户声明的析构函数时生成。自动生成的析构函数是noexcept类型的，并且如果继承的基类函数的析构函数为虚函数，则生成的析构函数也是虚函数。\",\"复制构造函数\",\"仅在类中不包含用户声明的复制构造函数时生成。如果该类声明了移动操作函数，则自动生成的复制构造函数将被会标记为delete，也就是说如果类中仅声明了移动操作函数而未声明复制操作函数，则编译器不允许调用该类的复制构造/赋值函数，见下例。\",\"class A { public: A() = default; A(A&&) noexcept = default; // 显式声明移动构造函数 A& operator=(A&&) noexcept = default; // 显式声明移动赋值运算符 }; int main() { A obj1; A obj2(obj1); // error: use of deleted function 'constexpr A::A(const A&)' return 0; }\",\"复制赋值函数\",\"仅在类中不包括用户声明的复制赋值函数时才会生成，同样如果该类中声明了移动构造函数，则不允许调用该类的复制赋值函数。\",\"复制构造函数和复制赋值函数时彼此独立的，用户声明了其中一个不会影响自动生成另一个。\",\"移动构造函数和移动赋值函数\",\"仅在类中不包括用户声明的任何（复制/移动）赋值操作、移动操作和析构函数时才会生成。如果该类中声明了复制构造函数，则不会生成移动操作函数（移动操作可以调用但是实际上转化为赋值操作）。\",\"class A { public: A() = default; A(const A& a) { // 复制构造函数 std::cout << \\\"copy is called\\\" << std::endl; } A& operator=(const A&) = default; // A(A&&) noexcept = default; // 显式声明移动构造函数 }; int main() { A obj1; A obj3(std::move(obj1)); // 调用移动构造函数 return 0; } // 输出：copy is called // 如果取消移动构造函数注释，则输出：(空)\",\"移动构造函数和移动赋值函数相互不独立，声明了其中一个就会阻止编译器生成另一个，如下例所示：\",\"class A { public: A() = default; A(A&&) noexcept = default; // 显式声明移动构造函数 // A& operator=(A&&) noexcept = default; // 显式声明移动赋值运算符 }; int main() { A obj1; A obj2(std::move(obj1)); // 没问题 A obj3; obj3 = std::move(obj1); // error: use of deleted function 'constexpr A& A::operator=(const A&)' return 0; }\",\"大三率（Rule of Three）原则\",\"如果用户声明了复制构造函数、复制赋值函数和析构函数中的任意一个，则应该同时声明所有的这三个。\",\"基于此原则C++规定：只要用户声明了析构函数，就不会生成移动操作，例如下例所示：\",\"// 移动操作会调用自动生成的移动构造函数 class StringTable { public: StringTable() {} … //插入、删除、查找等函数，但是没有拷贝/移动/析构功能 private: std::map<int, std::string> values; }; // 移动操作会调用赋值构造函数 class StringTable { public: StringTable() { makeLogEntry(\\\"Creating StringTable object\\\"); } //增加的 ~StringTable() //也是增加的 { makeLogEntry(\\\"Destroying StringTable object\\\"); } … //其他函数同之前一样 private: std::map<int, std::string> values; //同之前一样 };\"]},\"62\":{\"h\":\"第四章：智能指针\",\"t\":[\"《Effective Modern C++》阅读笔记（四）\"]},\"63\":{\"h\":\"条款18：对于独占资源使用\",\"t\":[\"std::unique_ptr是对裸指针的简单封装，有着和裸指针相同的尺寸，同时实现RAII特性。其实现的是对象专属所有权语义，不能被复制只能移动。\",\"基于std::unique_ptr实现的工厂模式：\",\"class Investment { … }; class Stock: public Investment { … }; class Bond: public Investment { … }; class RealEstate: public Investment { … }; template<typename... Ts> // 返回指向对象的std::unique_ptr， std::unique_ptr<Investment> // 对象使用给定实参创建 Investment::makeInvestment(Ts&&... params); { … auto pInvestment = // pInvestment是std::unique_ptr<Investment>类型 makeInvestment( arguments ); … } // 销毁 *pInvestment\",\"std::unique_ptr对象超出作用于后默认调用delete析构对象所指向的对象，同时也支持自定义析构函数，自定义析构函数的传入参数需要时指向对象类型的裸指针，例如：\",\"template<typename... Ts> auto Investment::makeInvestment(Ts&&... params) // C++14返回值推导 { auto delInvmt = [](Investment* pInvestment) // 现在在makeInvestment里 { makeLogEntry(pInvestment); delete pInvestment; }; std::unique_ptr<Investment, decltype(delInvmt)> pInv(nullptr, delInvmt); if ( … ) { pInv.reset(new Stock(std::forward<Ts>(params)...)); } else if ( … ) { pInv.reset(new Bond(std::forward<Ts>(params)...)); } else if ( … ) { pInv.reset(new RealEstate(std::forward<Ts>(params)...)); } return pInv; }\",\"不管makeInvestment实际创建的什么类型的对象，它最终在lambda表达式中，作为Investment*对象被删除。这意味着我们通过基类指针删除派生类实例，为此，基类Investment必须有虚析构函数：\",\"class Investment { public: … virtual ~Investment(); // 关键设计部分！ … };\",\"最后std::unique_ptr可以转换成std::shared_ptr，但是不能反向转换：\",\"std::shared_ptr<Investment> sp = // 将std::unique_ptr转为std::shared_ptr makeInvestment(arguments);\"]},\"64\":{\"h\":\"条款19：对于共享资源使用\",\"t\":[\"与std::unique相反，std::shared_ptr实现的是对象共享所有权语义，同时在对象不被任何其他对象所有的时候进行析构。\"]},\"65\":{\"h\":\"引用计数\",\"t\":[\"std::shared_ptr通过维护引用计算来实现复制和赋值操作：如果sp1使用sp2进行初始化，则二者指向对象的引用计数加1；而如果sp1和sp2之间使用赋值操作，即sp1=sp2，则sp1原来指向对象的引用计数减1，sp2指向对象的引用计数加1；如果sp1或者sp2超出作用域，则对应对象的引用计数减1。如果引用计数减为0，则该对象自动被析构（undefined behavior和double free问题的高发地）。\",\"std::shared_ptr的存储结构为：\",\"std::shared_ptr对象本身大小为两个指针：指向对象（T object）的裸指针和指向控制块（control block）的控制块指针。其中控制块中包含的内容有：\",\"引用计数：原子类型，递增和递减都是原子操作，用来记录object被引用个数；\",\"弱计数：std::weak_ptr引用数，后文有介绍：\",\"其他数据：例如自定义析构函数，分配器等。\",\"std::shared_ptr在多线程下可以保证引用计数的线程安全，但是保证不了所指对象的线程安全。\",\"控制块的创建主要在以下几种情况：\",\"使用std::make_shared总是会创建一个控制块；\",\"从std::unique_ptr出发初始化std::shared_ptr会创建控制块，创建完成后unique_ptr会被置空；\",\"从裸指针出发初始化std::shared_ptr会创建控制块，创建完成后请不要再使用裸指针。\"]},\"66\":{\"h\":\"自定义析构函数\",\"t\":[\"与std::unique_ptr类似，std::shared_ptr同样支持自定义析构函数，但是在定义时略有区别：unique_ptr的析构函数是智能指针类型的一部分，而shared_ptr则不是，如下例所示：\",\"auto loggingDel = [](Widget *pw) // 自定义删除器 { makeLogEntry(pw); delete pw; }; std::unique_ptr< // std::unique_ptr删除器类型是 Widget, decltype(loggingDel) // 智能指针类型的一部分 > upw(new Widget, loggingDel); std::shared_ptr<Widget> // std::shared_ptr删除器类型不是 spw(new Widget, loggingDel); // 智能指针类型的一部分\",\"同一类型不同的析构函数的shared_ptr也被视为是同一种类型，例如：\",\"auto customDeleter1 = [](Widget *pw) { … }; // 自定义删除器， auto customDeleter2 = [](Widget *pw) { … }; // 每种类型不同 std::shared_ptr<Widget> pw1(new Widget, customDeleter1); std::shared_ptr<Widget> pw2(new Widget, customDeleter2); std::vector<std::shared_ptr<Widget>> vpw{ pw1, pw2 };\"]},\"67\":{\"h\":\"\",\"t\":[\"需要在类对象的内部中获得一个指向当前对象的std::shared_ptr对象，可能会采用的做法是：\",\"class Bad { public: std::shared_ptr<Bad> getptr() { return std::shared_ptr<Bad>(this); // （1） } ~Bad() { std::cout << \\\"Bad::~Bad() called\\\" << std::endl; } }; int main() { std::shared_ptr<Bad> bp1(new Bad()); // （2) std::shared_ptr<Bad> bp2 = bp1->getptr(); // （3） }\",\"代码（1）处使用this创建了一个新的shared_ptr对象及控制块，注意该控制块中的引用计数是1，如果*this本身就已经被另一个shared_ptr指向（即（2）中的bp1），则bp1和bp2指向相同的对象，但是各自都包含一个引用计数为1的控制块，这就导致会出现double free的情况。\",\"正确的做法是：\",\"struct Good : std::enable_shared_from_this<Good> // 注意这里的继承 { public: std::shared_ptr<Good> getptr() { return shared_from_this(); // 使用shared_from_this() } ~Good() { std::cout << \\\"Good::~Good() called\\\" << std::endl; } }; int main() { { std::shared_ptr<Good> gp1(new Good()); std::shared_ptr<Good> gp2 = gp1->getptr(); } system(\\\"pause\\\"); }\",\"std::enable_shared_from_this是一个模板基类，其中定义了一个函数std::shared_from_this，其在创建指向*this对象的shared_ptr前会检查是否已有*this对应的控制块：如果有则直接返回一个新的 shared_ptr，引用计数增加；如果没有则创建一个新的 shared_ptr 并将其存储在 shared_from_this 的内部成员中，然后返回这个 shared_ptr。\"]},\"68\":{\"h\":\"条款20：当 可能悬空时使用\",\"t\":[\"std::weak_ptr不是一个独立的指针，而是std::shared_ptr的一种补充。weak_ptr一般通过shared_ptr来创建，创建后的weak_ptr指向与shared_ptr指向相同的位置，但是不会影响shared_ptr控制块的引用计数，这带来的问题就是weak_ptr可能悬空，如下例所示：\",\"auto spw = // spw创建之后，指向的Widget的 std::make_shared<Widget>(); // 引用计数（ref count，RC）为1。 std::weak_ptr<Widget> wpw(spw); // wpw指向与spw所指相同的Widget。RC仍为1 spw = nullptr; // RC变为0，Widget被销毁。 // wpw现在悬空\",\"判断weak_ptr是否悬空的方法为：\",\"wpw.expired();\",\"weak_ptr可以创建对应的shared_ptr，然后通过判断返回的shared_ptr指针来判断是否悬空：\",\"std::shared_ptr<Widget> spw1 = wpw.lock(); // 如果wpw过期，spw1就为空 auto spw2 = wpw.lock(); // 同上，但是使用auto\",\"weak_ptr的主要用途是解决shared_ptr的循环引用问题：考虑一个持有三个对象A、B、C的数据结构，A和C共享B的所有权，因此持有std::shared_ptr，同时B还保存有A的所有权，如下图所示：\",\"如果B使用shared_ptr保存对A的引用，这会使得A和B相互引用，最终导致AB无法成功析构造成内存泄漏。解决办法就是B对A的引用换为weak_ptr，但是B在访问A时需要先确认是否悬空。\"]},\"69\":{\"h\":\"条款21：优先考虑使用 和 ，而非直接使用\",\"t\":[\"std::make_shared和std::make_unique只是将参数包完美转发到索要创建的对象的构造函数中，然后返回对应的指针类型：\",\"template<typename T, typename... Ts> std::unique_ptr<T> make_unique(Ts&&... params) { return std::unique_ptr<T>(new T(std::forward<Ts>(params)...)); }\",\"创建智能指针的方式有两种，使用make函数和使用new运算符创建：\",\"auto upw1(std::make_unique<Widget>()); // 使用make函数 std::unique_ptr<Widget> upw2(new Widget); // 不使用make函数 auto spw1(std::make_shared<Widget>()); // 使用make函数 std::shared_ptr<Widget> spw2(new Widget); // 不使用make函数\"]},\"70\":{\"h\":\"适用 系列函数构造情形\"},\"71\":{\"h\":\"情形一：避免潜在内存泄漏\",\"t\":[\"函数processWidget按照某种优先级处理Widget：\",\"void processWidget(std::shared_ptr<Widget> spw, int priority);\",\"函数computePriority用来计算优先级：\",\"int computePriority();\",\"如果使用new运算符：\",\"processWidget(std::shared_ptr<Widget>(new Widget), // 潜在的资源泄漏！ computePriority());\",\"由于在运行时一个函数的实参必须先被计算，然后才能执行函数体，所以在调用processWidget之前会执行：\",\"new Widget在堆上创建了Widget对象；\",\"负责管理new出来指针的std::shared_ptr<Widget>构造函数必须被执行；\",\"执行computePriority。\",\"但实际上编译器会对上述过程进行重排：\",\"new Widget在堆上创建了Widget对象；\",\"执行computePriority;\",\"负责管理new出来指针的std::shared_ptr<Widget>构造函数必须被执行。\",\"不幸的是第2步执行computePriority时发生了异常，导致新分配的Widget并没有被shared_ptr接管，进而造成内存泄漏。\",\"而如果使用make函数，则没有类似的问题：\",\"processWidget(std::make_shared<Widget>(), // 没有潜在的资源泄漏 computePriority());\"]},\"72\":{\"h\":\"情形二：避免多次内存分配\",\"t\":[\"使用new创建shared_ptr会进行两次内存分配：对象分配和控制块内存分配。\",\"std::shared_ptr<Widget> spw(new Widget);\",\"而使用make_shared则会分配一整块内存单块（single chunck），包含对象和控制块：\",\"auto spw = std::make_shared<Widget>();\"]},\"73\":{\"h\":\"不适用 系列函数构造情形\"},\"74\":{\"h\":\"使用自定义构造器\",\"t\":[\"如果智能指针需要使用自定义构造器，则只能采用new构造形式：\",\"auto widgetDeleter = [](Widget* pw) { … }; std::unique_ptr<Widget, decltype(widgetDeleter)> upw(new Widget, widgetDeleter); std::shared_ptr<Widget> spw(new Widget, widgetDeleter);\"]},\"75\":{\"h\":\"构造函数匹配问题\",\"t\":[\"如果类的构造函数存在重载，分为std::initializer_list类型作为参数和非作std::initializer_list类型的参数构造，此时如果用大括号创建的对象更倾向于使用前者，而用小括号创建对象将调用后者构造函数。对于使用make系列函数创建方法，则可能无法创建出对应的类型。\",\"如下例所示，创建的分别是指向一个包含10个元素，每个元素都是20的std::vector对象的unique_ptr和shared_ptr。\",\"auto upv = std::make_unique<std::vector<int>>(10, 20); auto spv = std::make_shared<std::vector<int>>(10, 20);\",\"但是如果想要创建一个只包含10和20的vector对象则必须要使用vector。\"]},\"76\":{\"h\":\"高内存占用对象以及生命周期就的weak_ptr\",\"t\":[\"前面提到make_shared系列函数会比new要少分配一次内存，原因在于指向的对象和控制块位于同一块连续的内存区域。当对象的引用计数降为0，对象被销毁（即析构函数被调用）。但是因为控制块和对象被放在同一块分配的内存块中，直到控制块的内存也被销毁，对象占用的内存才真正被释放。\",\"控制块中包含了引用计数和弱引用计数。前者用来记录有多少std::shared_ptr指向控制块，后者用来记录有多少shared_ptr和std::weak_ptr指向控制块。\",\"class ReallyBigType { … }; auto pBigObj = //通过std::make_shared std::make_shared<ReallyBigType>(); //创建一个大对象 … // 创建std::shared_ptrs和std::weak_ptrs // 指向这个对象，使用它们 … // 最后一个std::shared_ptr在这销毁， // 但std::weak_ptrs还在 … // 在这个阶段，原来分配给大对象的内存还分配着 … // 最后一个std::weak_ptr在这里销毁； // 控制块和对象的内存被释放\",\"直接只用new，一旦最后一个std::shared_ptr被销毁，ReallyBigType对象的内存就会被释放：\",\" class ReallyBigType { … }; // 和之前一样 std::shared_ptr<ReallyBigType> pBigObj(new ReallyBigType); // 通过new创建大对象 … // 像之前一样，创建std::shared_ptrs和std::weak_ptrs // 指向这个对象，使用它们 … // 最后一个std::shared_ptr在这销毁, // 但std::weak_ptrs还在； // 对象的内存被释放 … // 在这阶段，只有控制块的内存仍然保持分配 … // 最后一个std::weak_ptr在这里销毁； // 控制块内存被释放\"]},\"77\":{\"h\":\"条款22：当使用Pimpl惯用法，请在实现文件中定义特殊成员函数\",\"t\":[\"Pimpl（pointer to implementation）指的是将类数据成员替换成一个指向包含具体实现的类（或结构体）的指针，并将放在主类（primary class）的数据成员们移动到实现类（implementation class）去，而这些数据成员的访问将通过指针间接访问。\",\"Pimpl的好处是将类的嵌套关系进行解耦，减少编译时间。举个例子，类Widget的定义如下：\",\"class Widget() { // 定义在头文件“widget.h” public: Widget(); … private: std::string name; std::vector<double> data; Gadget g1, g2, g3; // Gadget是用户自定义的类型 };\",\"因为类Widget的数据成员包含有类型std::string，std::vector和Gadget，必须引入#include <string>，<vector>以及gadget.h。这些头文件将会增加类Widget使用者的编译时间，并且让这些使用者依赖于这些头文件。如果一个头文件的内容变了，类Widget使用者也必须要重新编译。\",\"如果改成Pimpl的形式则不会存在这个问题，因此pImpl是一个指向不完全类型的指针，与类Impl的具体实现无关：\",\"/********** widget.h *********/ class Widget { public: Widget(); ~Widget(); // 析构函数在后面会分析 … private: struct Impl; // 声明一个实现结构体 Impl *pImpl; // 以及指向它的指针 }; /********** widget.cpp *********/ #include \\\"widget.h\\\" #include \\\"gadget.h\\\" #include <string> #include <vector> struct Widget::Impl { // 含有之前在Widget中的数据成员的 std::string name; // Widget::Impl类型的定义 std::vector<double> data; Gadget g1,g2,g3; }; Widget::Widget() // 为此Widget对象分配数据成员 : pImpl(new Impl) {} Widget::~Widget() // 这里非常重要 { delete pImpl; } // 需要析构指针，不然会内存泄漏\",\"具有自动内存管理特性的std::unique_ptr看起来天然适合做这种工作，如果上述Pimpl类修改为如下则会发生错误：\",\"/********** widget.h *********/ class Widget { public: Widget(); … private: struct Impl; std::unique_ptr<Impl> pImpl; // 使用智能指针而不是原始指针 }; /********** widget.cpp *********/ #include \\\"widget.h\\\" #include \\\"gadget.h\\\" #include <string> #include <vector> struct Widget::Impl { // 跟之前一样 std::string name; std::vector<double> data; Gadget g1,g2,g3; }; Widget::Widget() // 通过std::make_unique : pImpl(std::make_unique<Impl>()) // 来创建std::unique_ptr {} // unique_ptr不需要析构函数 /********** test.cpp *********/ #include \\\"widget.h\\\" Widget w; // 错误！\",\"错误的原因在于当对象w被析构时（例如离开了作用域），其析构函数被调用。由于没有为unique_ptr声明一个析构函数，编译器会自动生成默认析构函数，使用delete来销毁内置于unique_ptr的原始指针。而在使用delete之前会通过static_assert来确保原始指针指向的类型不是一个不完整类型。此处显然static_assert检查会失败，这通常是错误信息的来源。这些错误信息只在对象w销毁的地方出现，因为类Widget的析构函数，正如其他的编译器生成的特殊成员函数一样，是暗含inline属性的。错误信息自身往往指向对象w被创建的那行，因为这行代码明确地构造了这个对象，导致了后面潜在的析构。\",\"解决这个问题只需要确保在编译器生成销毁std::unique_ptr<Widget::Impl>的代码之前，Widget::Impl已经是一个完整类型即可。成功编译的关键就是在widget.cpp文件内，让编译器在看到Widget的析构函数实现之前先定义Widget::Impl：\",\"/********** widget.h *********/ class Widget { public: Widget(); ~Widget(); //只有声明语句 … private: struct Impl; std::unique_ptr<Impl> pImpl; // 使用智能指针而不是原始指针 }; /********** widget.cpp *********/ #include \\\"widget.h\\\" #include \\\"gadget.h\\\" #include <string> #include <vector> struct Widget::Impl { // 跟之前一样 std::string name; std::vector<double> data; Gadget g1,g2,g3; }; Widget::Widget() // 跟之前一样 : pImpl(std::make_unique<Impl>()) {} Widget::~Widget() // 析构函数的定义 {} // 或者 Widget::~Widget() = default; // 同上述代码效果一致\",\"但是声明一个类Widget的析构函数会阻止编译器生成移动操作，所以想要支持移动操作还要声明相关的函数。如果按以下方式实现：\",\"/********** widget.h *********/ class Widget { public: Widget(); ~Widget(); //只有声明语句 Widget(Widget&& rhs) = default; // 思路正确， Widget& operator=(Widget&& rhs) = default; // 但代码错误 … private: struct Impl; std::unique_ptr<Impl> pImpl; // 使用智能指针而不是原始指针 };\",\"编译器生成的移动赋值操作符，在重新赋值之前，需要先销毁指针pImpl指向的对象。然而在Widget的头文件里，pImpl指针指向的是一个不完整类型，所以这种做法还是会导致错误，对此解决的办法与前面类似：\",\"/********** widget.h *********/ class Widget { public: Widget(); ~Widget(); //只有声明语句 Widget(Widget&& rhs); //只有声明 Widget& operator=(Widget&& rhs); … private: struct Impl; std::unique_ptr<Impl> pImpl; // 使用智能指针而不是原始指针 }; /********** widget.cpp *********/ struct Widget::Impl { … }; // 跟之前一样 Widget::Widget() // 跟之前一样 : pImpl(std::make_unique<Impl>()) {} Widget::~Widget() = default; // 跟之前一样 Widget::Widget(Widget&& rhs) = default; // 这里定义 Widget& Widget::operator=(Widget&& rhs) = default;\",\"如果将unique_ptr换成std::shared_ptr则完全没有上述问题：\",\"/********** widget.h *********/ class Widget { public: Widget(); … // 没有析构函数和移动操作的声明 private: struct Impl; std::shared_ptr<Impl> pImpl; // 用std::shared_ptr }; // 而不是std::unique_ptr /********** widget.cpp *********/ Widget w1; auto w2(std::move(w1)); // 移动构造w2 w1 = std::move(w2); // 移动赋值w1\",\"unique_ptr和shared_ptr在pImpl指针上的表现上的区别的深层原因在于支持自定义删除器的方式不同。unique_ptr删除器的类型是智能指针对象本身的一部分，这让编译器有可能生成更小的运行时数据结构和更快的运行代码。带来的限制就是unique_ptr指向的类型，在编译器的生成特殊成员函数（如析构函数，移动操作）被调用时，必须已经是一个完整类型。而shared_ptr删除器的类型不是该智能指针的一部分而是控制块的一部分，在对象析构器前控制块存在则所指的对象一定存在，因此当编译器生成的特殊成员函数被使用的时候，指向的对象不必是一个完整类型。\"]},\"78\":{\"h\":\"\",\"t\":[\"404 Not Found\"]}},\"dirtCount\":0,\"index\":[[\"必须已经是一个完整类型\",{\"1\":{\"77\":1}}],[\"必须引入\",{\"1\":{\"77\":1}}],[\"被调用时\",{\"1\":{\"77\":1}}],[\"被任何像指针一样的东西\",{\"1\":{\"40\":1}}],[\"带来的限制就是unique\",{\"1\":{\"77\":1}}],[\"带有与x的声明等价的\",{\"1\":{\"36\":1}}],[\"然而在widget的头文件里\",{\"1\":{\"77\":1}}],[\"然后才能执行函数体\",{\"1\":{\"71\":1}}],[\"然后返回对应的指针类型\",{\"1\":{\"69\":1}}],[\"然后返回这个\",{\"1\":{\"67\":1}}],[\"然后通过判断返回的shared\",{\"1\":{\"68\":1}}],[\"然后执行一些与本条款无关的操作后中止\",{\"1\":{\"52\":1}}],[\"然后expr的类型与paramtype进行模式匹配来决定t\",{\"1\":{\"30\":1}}],[\"然后再该起始点顺序访问\",{\"1\":{\"19\":1}}],[\"然后写入磁盘中的sst中\",{\"1\":{\"18\":1}}],[\"然后加入到本地的区块链中\",{\"1\":{\"13\":1}}],[\"思路正确\",{\"1\":{\"77\":1}}],[\"或者\",{\"1\":{\"77\":1}}],[\"或结构体\",{\"1\":{\"77\":1}}],[\"让编译器在看到widget的析构函数实现之前先定义widget\",{\"1\":{\"77\":1}}],[\"让编译器生成更好的目标代码\",{\"1\":{\"52\":1}}],[\"成功编译的关键就是在widget\",{\"1\":{\"77\":1}}],[\"成员地线程安全\",{\"0\":{\"58\":1}}],[\"成员函数\",{\"1\":{\"57\":1}}],[\"解决这个问题只需要确保在编译器生成销毁std\",{\"1\":{\"77\":1}}],[\"解决办法就是b对a的引用换为weak\",{\"1\":{\"68\":1}}],[\"导致了后面潜在的析构\",{\"1\":{\"77\":1}}],[\"导致新分配的widget并没有被shared\",{\"1\":{\"71\":1}}],[\"正如其他的编译器生成的特殊成员函数一样\",{\"1\":{\"77\":1}}],[\"正确的做法是\",{\"1\":{\"67\":1}}],[\"此处显然static\",{\"1\":{\"77\":1}}],[\"此时如果用大括号创建的对象更倾向于使用前者\",{\"1\":{\"75\":1}}],[\"此时pair中的swap是否被标记为noexcept取决于t1和t2中的swap函数是否被标记为except\",{\"1\":{\"52\":1}}],[\"跟之前一样\",{\"1\":{\"77\":6}}],[\"具有自动内存管理特性的std\",{\"1\":{\"77\":1}}],[\"具体来看各个部分结构体的定义\",{\"1\":{\"23\":1}}],[\"具体可分为两种类型\",{\"1\":{\"8\":1}}],[\"含有之前在widget中的数据成员的\",{\"1\":{\"77\":1}}],[\"因为这行代码明确地构造了这个对象\",{\"1\":{\"77\":1}}],[\"因为类widget的析构函数\",{\"1\":{\"77\":1}}],[\"因为类widget的数据成员包含有类型std\",{\"1\":{\"77\":1}}],[\"因此当编译器生成的特殊成员函数被使用的时候\",{\"1\":{\"77\":1}}],[\"因此pimpl是一个指向不完全类型的指针\",{\"1\":{\"77\":1}}],[\"因此持有std\",{\"1\":{\"68\":1}}],[\"因此其构造出来的对象在编译时也是已知的\",{\"1\":{\"57\":1}}],[\"因此不适合被标记为noexception\",{\"1\":{\"53\":1}}],[\"因此可以提供了更多的优化机会\",{\"1\":{\"52\":1}}],[\"定义在头文件\",{\"1\":{\"77\":1}}],[\"减少编译时间\",{\"1\":{\"77\":1}}],[\"去\",{\"1\":{\"77\":1}}],[\"去掉右值的引用部分\",{\"1\":{\"37\":1}}],[\"指的是将类数据成员替换成一个指向包含具体实现的类\",{\"1\":{\"77\":1}}],[\"指向这个对象\",{\"1\":{\"76\":2}}],[\"指向对象\",{\"1\":{\"65\":1}}],[\"指向的对象不必是一个完整类型\",{\"1\":{\"77\":1}}],[\"指向的widget的\",{\"1\":{\"68\":1}}],[\"指向的widget类型的\",{\"1\":{\"40\":1}}],[\"指向的值的比较函数\",{\"1\":{\"40\":1}}],[\"指向常量对象\",{\"1\":{\"32\":1}}],[\"请在实现文件中定义特殊成员函数\",{\"0\":{\"77\":1}}],[\"请求\",{\"1\":{\"8\":1}}],[\"像之前一样\",{\"1\":{\"76\":1}}],[\"直接只用new\",{\"1\":{\"76\":1}}],[\"直到控制块的内存也被销毁\",{\"1\":{\"76\":1}}],[\"控制块内存被释放\",{\"1\":{\"76\":1}}],[\"控制块和对象的内存被释放\",{\"1\":{\"76\":1}}],[\"控制块中包含了引用计数和弱引用计数\",{\"1\":{\"76\":1}}],[\"控制块的创建主要在以下几种情况\",{\"1\":{\"65\":1}}],[\"前者用来记录有多少std\",{\"1\":{\"76\":1}}],[\"前面提到make\",{\"1\":{\"76\":1}}],[\"前一个区块的哈希\",{\"1\":{\"9\":1}}],[\"高内存占用对象以及生命周期就的weak\",{\"0\":{\"76\":1}}],[\"分为std\",{\"1\":{\"75\":1}}],[\"分配器等\",{\"1\":{\"65\":1}}],[\"情形二\",{\"0\":{\"72\":1}}],[\"情形一\",{\"0\":{\"71\":1}}],[\"进而造成内存泄漏\",{\"1\":{\"71\":1}}],[\"进而导致安全问题\",{\"1\":{\"52\":1}}],[\"但代码错误\",{\"1\":{\"77\":1}}],[\"但std\",{\"1\":{\"76\":2}}],[\"但实际上编译器会对上述过程进行重排\",{\"1\":{\"71\":1}}],[\"但是声明一个类widget的析构函数会阻止编译器生成移动操作\",{\"1\":{\"77\":1}}],[\"但是因为控制块和对象被放在同一块分配的内存块中\",{\"1\":{\"76\":1}}],[\"但是b在访问a时需要先确认是否悬空\",{\"1\":{\"68\":1}}],[\"但是使用auto\",{\"1\":{\"68\":1}}],[\"但是各自都包含一个引用计数为1的控制块\",{\"1\":{\"67\":1}}],[\"但是保证不了所指对象的线程安全\",{\"1\":{\"65\":1}}],[\"但是不会影响shared\",{\"1\":{\"68\":1}}],[\"但是不能反向转换\",{\"1\":{\"63\":1}}],[\"但是不推荐这么做\",{\"1\":{\"53\":1}}],[\"但是没有拷贝\",{\"1\":{\"61\":1}}],[\"但是const变量不一定是constexpr变量\",{\"1\":{\"55\":1}}],[\"但是它们调用的函数可能会抛出异常\",{\"1\":{\"53\":1}}],[\"但是这样对于移动操作不会产生异常的类来说性能上还有很大的提升空间\",{\"1\":{\"52\":1}}],[\"但是这样一方面会造成代码冗长\",{\"1\":{\"40\":1}}],[\"但是如果想要创建一个只包含10和20的vector对象则必须要使用vector\",{\"1\":{\"75\":1}}],[\"但是如果执行push\",{\"1\":{\"52\":1}}],[\"但是如果要声明类中的嵌套类型\",{\"1\":{\"45\":1}}],[\"但是此时该临时变量已经析构\",{\"1\":{\"41\":1}}],[\"但是实际上m中每个元素的类型为std\",{\"1\":{\"40\":1}}],[\"但是auto\",{\"1\":{\"37\":1}}],[\"但是在定义时略有区别\",{\"1\":{\"66\":1}}],[\"但是在这些情况下auto实际上使用模板类型推导的那一套规则在工作\",{\"1\":{\"36\":1}}],[\"但是在执行节点生成区块时hc的高度为101\",{\"1\":{\"13\":1}}],[\"但是由于网络异步问题\",{\"1\":{\"13\":1}}],[\"负责管理new出来指针的std\",{\"1\":{\"71\":2}}],[\"潜在的资源泄漏\",{\"1\":{\"71\":1}}],[\"避免多次内存分配\",{\"0\":{\"72\":1}}],[\"避免潜在内存泄漏\",{\"0\":{\"71\":1}}],[\"避免长时间无响应\",{\"1\":{\"13\":1}}],[\"系列函数构造情形\",{\"0\":{\"70\":1,\"73\":1}}],[\"适用\",{\"0\":{\"70\":1}}],[\"考虑一个持有三个对象a\",{\"1\":{\"68\":1}}],[\"判断weak\",{\"1\":{\"68\":1}}],[\"处使用this创建了一个新的shared\",{\"1\":{\"67\":1}}],[\"代码\",{\"1\":{\"67\":1}}],[\"需要先销毁指针pimpl指向的对象\",{\"1\":{\"77\":1}}],[\"需要析构指针\",{\"1\":{\"77\":1}}],[\"需要在类对象的内部中获得一个指向当前对象的std\",{\"1\":{\"67\":1}}],[\"需要加上noexcept\",{\"1\":{\"53\":1}}],[\"弱计数\",{\"1\":{\"65\":1}}],[\"递增和递减都是原子操作\",{\"1\":{\"65\":1}}],[\"与类impl的具体实现无关\",{\"1\":{\"77\":1}}],[\"与std\",{\"1\":{\"64\":1,\"66\":1}}],[\"与持久化后的文件的对应关系\",{\"1\":{\"25\":1}}],[\"关键设计部分\",{\"1\":{\"63\":1}}],[\"关于本站\",{\"0\":{\"1\":1}}],[\"~widget\",{\"1\":{\"77\":8}}],[\"~good\",{\"1\":{\"67\":2}}],[\"~bad\",{\"1\":{\"67\":2}}],[\"~investment\",{\"1\":{\"63\":1}}],[\"~stringtable\",{\"1\":{\"61\":1}}],[\"它最终在lambda表达式中\",{\"1\":{\"63\":1}}],[\"它也常用于拷贝运算符重载中\",{\"1\":{\"52\":1}}],[\"现在在makeinvestment里\",{\"1\":{\"63\":1}}],[\"现有的区块链系统存在的问题\",{\"1\":{\"6\":1}}],[\"销毁\",{\"1\":{\"63\":1}}],[\"有着和裸指针相同的尺寸\",{\"1\":{\"63\":1}}],[\"有限考虑使用\",{\"0\":{\"45\":1}}],[\"四\",{\"1\":{\"62\":1}}],[\"智能指针类型的一部分\",{\"1\":{\"66\":2}}],[\"智能指针\",{\"0\":{\"62\":1}}],[\"智能合约\",{\"1\":{\"8\":1}}],[\"增加的\",{\"1\":{\"61\":1}}],[\"析构功能\",{\"1\":{\"61\":1}}],[\"析构函数的定义\",{\"1\":{\"77\":1}}],[\"析构函数在后面会分析\",{\"1\":{\"77\":1}}],[\"析构函数\",{\"1\":{\"60\":1,\"61\":1}}],[\"删除\",{\"1\":{\"61\":1}}],[\"插入\",{\"1\":{\"61\":1}}],[\"就不会生成移动操作\",{\"1\":{\"61\":1}}],[\"原来分配给大对象的内存还分配着\",{\"1\":{\"76\":1}}],[\"原因在于指向的对象和控制块位于同一块连续的内存区域\",{\"1\":{\"76\":1}}],[\"原子类型\",{\"1\":{\"65\":1}}],[\"原则\",{\"1\":{\"61\":1}}],[\"原始版本\",{\"1\":{\"47\":1}}],[\"空\",{\"1\":{\"61\":1}}],[\"输出\",{\"1\":{\"61\":1}}],[\"赋值操作\",{\"1\":{\"61\":1}}],[\"赋值函数\",{\"1\":{\"61\":1}}],[\"显式声明移动赋值运算符\",{\"1\":{\"61\":2}}],[\"显式声明移动构造函数\",{\"1\":{\"61\":3}}],[\"见下例\",{\"1\":{\"61\":1}}],[\"见下文\",{\"1\":{\"52\":1}}],[\"仅在类中不包括用户声明的任何\",{\"1\":{\"61\":1}}],[\"仅在类中不包括用户声明的复制赋值函数时才会生成\",{\"1\":{\"61\":1}}],[\"仅在类中不包含用户声明的复制构造函数时生成\",{\"1\":{\"61\":1}}],[\"仅当类中不包含用户声明的任何构造函数时才会生成\",{\"1\":{\"61\":1}}],[\"自定义删除器\",{\"1\":{\"66\":2}}],[\"自定义析构函数\",{\"0\":{\"66\":1}}],[\"自定义析构函数的传入参数需要时指向对象类型的裸指针\",{\"1\":{\"63\":1}}],[\"自定义类的对象也可以是constexpr类别\",{\"1\":{\"57\":1}}],[\"自动生成的析构函数是noexcept类型的\",{\"1\":{\"61\":1}}],[\"自动生成的复制\",{\"1\":{\"60\":1}}],[\"非虚的\",{\"1\":{\"60\":1}}],[\"非限定域枚举可能存在的问题\",{\"1\":{\"46\":1}}],[\"编译器生成的移动赋值操作符\",{\"1\":{\"77\":1}}],[\"编译器会自动生成默认析构函数\",{\"1\":{\"77\":1}}],[\"编译器会自动生成\",{\"1\":{\"60\":1}}],[\"编译期可知常量\",{\"1\":{\"55\":1}}],[\"编译期不可知\",{\"1\":{\"55\":1}}],[\"移动构造w2\",{\"1\":{\"77\":1}}],[\"移动构造函数和移动赋值函数相互不独立\",{\"1\":{\"61\":1}}],[\"移动构造函数和移动赋值函数\",{\"1\":{\"61\":1}}],[\"移动构造函数会调用rhs中各个非静态成员的复制\",{\"1\":{\"60\":1}}],[\"移动构造函数\",{\"1\":{\"60\":3}}],[\"移动操作\",{\"1\":{\"77\":1}}],[\"移动操作会调用赋值构造函数\",{\"1\":{\"61\":1}}],[\"移动操作会调用自动生成的移动构造函数\",{\"1\":{\"61\":1}}],[\"移动操作可以调用但是实际上转化为赋值操作\",{\"1\":{\"61\":1}}],[\"移动操作和析构函数时才会生成\",{\"1\":{\"61\":1}}],[\"移动\",{\"1\":{\"61\":2}}],[\"移动赋值w1\",{\"1\":{\"77\":1}}],[\"移动赋值运算符\",{\"1\":{\"60\":1}}],[\"移动赋值函数\",{\"1\":{\"60\":1}}],[\"复制\",{\"1\":{\"61\":1}}],[\"复制赋值函数和析构函数中的任意一个\",{\"1\":{\"61\":1}}],[\"复制赋值函数\",{\"1\":{\"60\":1,\"61\":1}}],[\"复制构造函数和复制赋值函数时彼此独立的\",{\"1\":{\"61\":1}}],[\"复制构造函数\",{\"1\":{\"60\":1,\"61\":2}}],[\"默认构造函数\",{\"1\":{\"60\":1,\"61\":1}}],[\"默认的内存释放函数\",{\"1\":{\"53\":1}}],[\"特种函数\",{\"0\":{\"60\":1}}],[\"特殊情况\",{\"0\":{\"33\":1}}],[\"8\",{\"1\":{\"57\":1}}],[\"8b\",{\"1\":{\"24\":1,\"25\":1}}],[\"设定它的x和y值\",{\"1\":{\"57\":1}}],[\"+\",{\"1\":{\"57\":2}}],[\"结果有3^numconds个元素\",{\"1\":{\"56\":1}}],[\"条件的个数\",{\"1\":{\"56\":1}}],[\"条款9\",{\"0\":{\"45\":1}}],[\"条款8\",{\"0\":{\"44\":1}}],[\"条款7\",{\"0\":{\"43\":1}}],[\"条款6\",{\"0\":{\"41\":1}}],[\"条款5\",{\"0\":{\"40\":1}}],[\"条款4\",{\"0\":{\"38\":1}}],[\"条款3\",{\"0\":{\"37\":1}}],[\"条款22\",{\"0\":{\"77\":1}}],[\"条款21\",{\"0\":{\"69\":1}}],[\"条款20\",{\"0\":{\"68\":1}}],[\"条款2\",{\"0\":{\"34\":1}}],[\"条款19\",{\"0\":{\"64\":1}}],[\"条款18\",{\"0\":{\"63\":1}}],[\"条款17\",{\"0\":{\"59\":1}}],[\"条款16\",{\"0\":{\"58\":1}}],[\"条款15\",{\"0\":{\"54\":1}}],[\"条款14\",{\"0\":{\"50\":1}}],[\"条款13\",{\"0\":{\"49\":1}}],[\"条款12\",{\"0\":{\"48\":1}}],[\"条款11\",{\"0\":{\"47\":1}}],[\"条款10\",{\"0\":{\"46\":1}}],[\"条款1\",{\"0\":{\"28\":1}}],[\"否则如果存在一个或者多个实参是编译器未知的\",{\"1\":{\"56\":1}}],[\"修饰自定义类对象\",{\"0\":{\"57\":1}}],[\"修饰函数\",{\"0\":{\"56\":1}}],[\"修饰变量\",{\"0\":{\"55\":1}}],[\"修改key对应的值为value\",{\"1\":{\"22\":1}}],[\"修改区块高度等\",{\"1\":{\"11\":1}}],[\"尽可能地使用\",{\"0\":{\"54\":1}}],[\"即析构函数被调用\",{\"1\":{\"76\":1}}],[\"即\",{\"1\":{\"67\":1}}],[\"即sp1=sp2\",{\"1\":{\"65\":1}}],[\"即字面值\",{\"1\":{\"56\":1}}],[\"即delete和delete\",{\"1\":{\"53\":1}}],[\"即null=0\",{\"1\":{\"44\":1}}],[\"相关注意事项\",{\"0\":{\"53\":1}}],[\"相同高度的哈希值是一致的并且hci​只是hsi​中的一个子树\",{\"1\":{\"13\":1}}],[\"表示a为一个拥有n个t类型数组的引用\",{\"1\":{\"52\":1}}],[\"数组和std\",{\"1\":{\"52\":1}}],[\"数据范围查询\",{\"1\":{\"17\":1}}],[\"数据单点查询\",{\"1\":{\"17\":1}}],[\"数据删除\",{\"1\":{\"17\":1}}],[\"数据添加或修改\",{\"1\":{\"17\":1}}],[\"比如\",{\"1\":{\"52\":1}}],[\"比较函数\",{\"1\":{\"40\":1}}],[\"标记为noexcept的函数调用没有标记为noexcept的函数时可以通过编译\",{\"1\":{\"53\":1}}],[\"标记会避免进行移动操作\",{\"1\":{\"52\":1}}],[\"标准库的swap是否noexcept有时依赖于用户定义的swap是否noexcept\",{\"1\":{\"52\":1}}],[\"作为investment\",{\"1\":{\"63\":1}}],[\"作为一元操作符提供更好的灵活性\",{\"1\":{\"52\":1}}],[\"作为数据成员\",{\"1\":{\"45\":1}}],[\"由此使用noexcept便能很好地解决这一问题\",{\"1\":{\"52\":1}}],[\"由于没有为unique\",{\"1\":{\"77\":1}}],[\"由于在运行时一个函数的实参必须先被计算\",{\"1\":{\"71\":1}}],[\"由于使用了多版本机制实际的读写流程要复杂一些\",{\"1\":{\"19\":1}}],[\"由于能够处理如此大量数据的节点越来越少\",{\"1\":{\"6\":1}}],[\"把w添加进vw\",{\"1\":{\"52\":1}}],[\"较少优化\",{\"1\":{\"52\":2}}],[\"极尽所能优化\",{\"1\":{\"52\":1}}],[\"来创建std\",{\"1\":{\"77\":1}}],[\"来中止程序不会出现程序未定义的情况\",{\"1\":{\"52\":1}}],[\"来实现\",{\"1\":{\"46\":1}}],[\"在对象析构器前控制块存在则所指的对象一定存在\",{\"1\":{\"77\":1}}],[\"在编译器的生成特殊成员函数\",{\"1\":{\"77\":1}}],[\"在编译期可知\",{\"1\":{\"57\":1}}],[\"在重新赋值之前\",{\"1\":{\"77\":1}}],[\"在这阶段\",{\"1\":{\"76\":1}}],[\"在这个阶段\",{\"1\":{\"76\":1}}],[\"在特定情境下如果用户没有显示声明特种函数\",{\"1\":{\"60\":1}}],[\"在c++98中调用栈会解开至f的调用方\",{\"1\":{\"52\":1}}],[\"在tee中的执行结果不会立刻写回链下的状态\",{\"1\":{\"12\":1}}],[\"在tee中会执行流程包括\",{\"1\":{\"12\":1}}],[\"首先对比c++98和c++11在声明函数不会抛出异常的写法\",{\"1\":{\"52\":1}}],[\"首页\",{\"0\":{\"0\":1}}],[\"加上noexcept主要有两方面的原因\",{\"1\":{\"52\":1}}],[\"加读写锁进行并发控制\",{\"1\":{\"21\":1}}],[\"中的bp1\",{\"1\":{\"67\":1}}],[\"中止程序\",{\"1\":{\"51\":1}}],[\"中完成\",{\"1\":{\"12\":1}}],[\"程序在任何时间都要维护完整的调用栈\",{\"1\":{\"51\":1}}],[\"程序继续执行\",{\"1\":{\"51\":1}}],[\"程序会调用std\",{\"1\":{\"51\":1}}],[\"程序会继续执行func的后续逻辑\",{\"1\":{\"51\":1}}],[\"程序会将控制权返回到该函数\",{\"1\":{\"51\":1}}],[\"程序会逐层返回到调用栈中的函数\",{\"1\":{\"51\":1}}],[\"程序会抛出一个异常\",{\"1\":{\"51\":1}}],[\"内存访问错误或其他错误\",{\"1\":{\"51\":1}}],[\"内存中缓存的block\",{\"1\":{\"23\":1}}],[\"内存中的block缓存\",{\"1\":{\"21\":1}}],[\"内存中最大的memtable数量\",{\"1\":{\"21\":1}}],[\"内存中有序key\",{\"1\":{\"17\":1}}],[\"异常或错误发生\",{\"1\":{\"51\":1}}],[\"出现异常后具体的处理流程如下\",{\"1\":{\"51\":1}}],[\"优先使用const类型的iterator\",{\"1\":{\"49\":1}}],[\"优先考虑使用限定域的枚举而不是非限定域的枚举\",{\"0\":{\"46\":1}}],[\"优先考虑使用\",{\"0\":{\"44\":1,\"47\":1,\"69\":1}}],[\"优先考虑\",{\"0\":{\"40\":1,\"49\":1}}],[\"报错\",{\"1\":{\"48\":2}}],[\"举个例子\",{\"1\":{\"48\":1,\"56\":1,\"57\":1,\"77\":1}}],[\"举个例子交易txn在存储节点上执行时hs的高度为99\",{\"1\":{\"13\":1}}],[\"若引用限定符为\",{\"1\":{\"48\":2}}],[\"重写base\",{\"1\":{\"48\":1}}],[\"重新计算tw​的根节点值hstate\",{\"1\":{\"13\":1}}],[\"除非是析构函数\",{\"1\":{\"48\":1}}],[\"派生类则不一定需要是虚函数\",{\"1\":{\"48\":1}}],[\"派生类重写\",{\"1\":{\"48\":1}}],[\"基类investment必须有虚析构函数\",{\"1\":{\"63\":1}}],[\"基类虚函数\",{\"1\":{\"48\":1}}],[\"基类和派生类函数的返回值和异常说明必须兼容\",{\"1\":{\"48\":1}}],[\"基类和派生类函数常量性const必须完全一样\",{\"1\":{\"48\":1}}],[\"基类和派生类函数形参类型必须完全一样\",{\"1\":{\"48\":1}}],[\"基类和派生类函数名必须完全一样\",{\"1\":{\"48\":1}}],[\"基类函数必须是virtual\",{\"1\":{\"48\":1}}],[\"基类函数需要满足以下条件\",{\"1\":{\"48\":1}}],[\"基于std\",{\"1\":{\"63\":1}}],[\"基于此原则c++规定\",{\"1\":{\"61\":1}}],[\"基于大括号的初始化形式\",{\"1\":{\"43\":1}}],[\"基于前一个链下状态hold​执行交易并获取读写集\",{\"1\":{\"12\":1}}],[\"拒绝const\",{\"1\":{\"47\":2}}],[\"拒绝char\",{\"1\":{\"47\":2}}],[\"拒绝void\",{\"1\":{\"47\":1}}],[\"拒绝float和double\",{\"1\":{\"47\":1}}],[\"拒绝bool\",{\"1\":{\"47\":1}}],[\"未定义函数\",{\"0\":{\"47\":1}}],[\"未定义行为\",{\"1\":{\"41\":1}}],[\"域中没有枚举名叫white\",{\"1\":{\"46\":1}}],[\"域内没有其他\",{\"1\":{\"46\":1}}],[\"也是增加的\",{\"1\":{\"61\":1}}],[\"也就是说如果类中仅声明了移动操作函数而未声明复制操作函数\",{\"1\":{\"61\":1}}],[\"也不要求在抛出异常后调用栈中函数内部变量析构时的顺序\",{\"1\":{\"52\":1}}],[\"也符合item5的建议\",{\"1\":{\"46\":1}}],[\"也没问题\",{\"1\":{\"46\":1}}],[\"也称枚举类\",{\"1\":{\"46\":1}}],[\"也可以\",{\"1\":{\"43\":1}}],[\"应改为限定域\",{\"1\":{\"46\":1}}],[\"→\",{\"1\":{\"45\":3}}],[\"大三率\",{\"1\":{\"61\":1}}],[\"大多数函数都是异常中立\",{\"1\":{\"53\":1}}],[\"大部分场景下typedef和using用法类似\",{\"1\":{\"45\":1}}],[\"大括号初始化可以解决小括号初始化存在的种种问题\",{\"1\":{\"43\":1}}],[\"大括号初始化的默认类型为std\",{\"1\":{\"43\":1}}],[\"绝对不会调用f\",{\"1\":{\"44\":1}}],[\"本质是一个指针类型\",{\"1\":{\"44\":1}}],[\"本文提出了无状态区块链slimchain\",{\"1\":{\"6\":1}}],[\"元素的值为10和20\",{\"1\":{\"43\":1}}],[\"所有的constexpr变量都是const变量\",{\"1\":{\"55\":1}}],[\"所有的元素的值都是20\",{\"1\":{\"43\":1}}],[\"所以这种做法还是会导致错误\",{\"1\":{\"77\":1}}],[\"所以想要支持移动操作还要声明相关的函数\",{\"1\":{\"77\":1}}],[\"所以在调用processwidget之前会执行\",{\"1\":{\"71\":1}}],[\"所以会导致未定义的行为\",{\"1\":{\"41\":1}}],[\"所以说下面这样的代码不会通过编译\",{\"1\":{\"36\":1}}],[\"所以需要加上时间窗口限制\",{\"1\":{\"13\":1}}],[\"所以交易执行得到的结果就是下面这样\",{\"1\":{\"12\":1}}],[\"小括号初始化可能会无法实现预期的构造函数\",{\"1\":{\"43\":1}}],[\"小括号初始化可能会因为c++的解析语法被视为函数声明\",{\"1\":{\"43\":1}}],[\"问题2\",{\"1\":{\"43\":1}}],[\"问题1\",{\"1\":{\"43\":1}}],[\"调用移动构造函数\",{\"1\":{\"61\":1}}],[\"调用constexpr\",{\"1\":{\"57\":1}}],[\"调用栈解开\",{\"1\":{\"51\":1}}],[\"调用\",{\"1\":{\"48\":2}}],[\"调用deleted函数\",{\"1\":{\"47\":1}}],[\"调用f\",{\"1\":{\"44\":1}}],[\"调用没有参数的构造函数构造对象\",{\"1\":{\"43\":1}}],[\"调用形式\",{\"1\":{\"29\":1}}],[\"声明一个实现结构体\",{\"1\":{\"77\":1}}],[\"声明一个函数w2\",{\"1\":{\"43\":1}}],[\"声明了其中一个就会阻止编译器生成另一个\",{\"1\":{\"61\":1}}],[\"声明重载函数\",{\"0\":{\"48\":1}}],[\"声明type为类型而不是一个成员变量\",{\"1\":{\"45\":1}}],[\"声明别名而不是\",{\"0\":{\"45\":1}}],[\"声明形式\",{\"1\":{\"29\":1}}],[\"没有析构函数和移动操作的声明\",{\"1\":{\"77\":1}}],[\"没有潜在的资源泄漏\",{\"1\":{\"71\":1}}],[\"没有来自f的异常\",{\"1\":{\"52\":2}}],[\"没有\",{\"1\":{\"45\":2}}],[\"没问题\",{\"1\":{\"43\":3,\"46\":2,\"55\":3,\"61\":1}}],[\"没找到的话会在磁盘中lsm\",{\"1\":{\"19\":1}}],[\"z\",{\"1\":{\"43\":3}}],[\"和之前一样\",{\"1\":{\"55\":1,\"57\":1,\"76\":1}}],[\"和析构函数都会被隐式地标记为noexcept\",{\"1\":{\"53\":1}}],[\"和cend\",{\"1\":{\"49\":1}}],[\"和只能指针\",{\"1\":{\"44\":1}}],[\"和花括号\",{\"1\":{\"43\":1}}],[\"和\",{\"0\":{\"43\":1,\"69\":1}}],[\"和上一个区块的快照hold​而不是摘要\",{\"1\":{\"13\":1}}],[\"区别使用\",{\"0\":{\"43\":1}}],[\"区块k中的读集\",{\"1\":{\"13\":1}}],[\"区块中所有交易的汇总哈希值\",{\"1\":{\"9\":1}}],[\"区块数据结构\",{\"0\":{\"9\":1}}],[\"区块观察节点\",{\"1\":{\"8\":1}}],[\"区块提议节点\",{\"1\":{\"8\":1}}],[\"区块相关数据存放在单独的存储节点\",{\"1\":{\"6\":1}}],[\"区块节点设为无状态\",{\"1\":{\"6\":1}}],[\"区块链网络分片\",{\"1\":{\"6\":1}}],[\"区块链节点存储和计算耦合\",{\"1\":{\"6\":1}}],[\"三个f的重载函数\",{\"1\":{\"44\":1}}],[\"三\",{\"1\":{\"42\":1}}],[\"转向现代c++\",{\"0\":{\"42\":1}}],[\"上面例子中\",{\"1\":{\"56\":1}}],[\"上例中highpriority变量的类型为std\",{\"1\":{\"41\":1}}],[\"上述结构都只介绍了核心的组件\",{\"1\":{\"23\":1}}],[\"上述流程只是简单的概括介绍\",{\"1\":{\"19\":1}}],[\"5f\",{\"1\":{\"47\":1}}],[\"5\",{\"1\":{\"41\":3,\"43\":2,\"56\":1,\"57\":2}}],[\"使用delete来销毁内置于unique\",{\"1\":{\"77\":1}}],[\"使用智能指针而不是原始指针\",{\"1\":{\"77\":4}}],[\"使用它们\",{\"1\":{\"76\":2}}],[\"使用自定义构造器\",{\"0\":{\"74\":1}}],[\"使用new创建shared\",{\"1\":{\"72\":1}}],[\"使用make函数\",{\"1\":{\"69\":2}}],[\"使用make函数和使用new运算符创建\",{\"1\":{\"69\":1}}],[\"使用shared\",{\"1\":{\"67\":1}}],[\"使用std\",{\"1\":{\"65\":1}}],[\"使用constexpr函数的结果\",{\"1\":{\"57\":1}}],[\"使用constexpr修饰函数表示如果传入该函数的实参值都是编译期已知的\",{\"1\":{\"56\":1}}],[\"使用cbegin\",{\"1\":{\"49\":1}}],[\"使用using声明函数别名\",{\"1\":{\"45\":1}}],[\"使用using声明类别名\",{\"1\":{\"45\":1}}],[\"使用typedef声明函数别名\",{\"1\":{\"45\":1}}],[\"使用typedef声明类别名\",{\"1\":{\"45\":1}}],[\"使用大括号则没上述问题\",{\"1\":{\"43\":1}}],[\"使用大括号初始化不可复制类的对象\",{\"1\":{\"43\":1}}],[\"使用大括号初始化非静态成员默认值\",{\"1\":{\"43\":1}}],[\"使用大括号初始化常规变量\",{\"1\":{\"43\":1}}],[\"使用实参10调用widget的一个构造函数\",{\"1\":{\"43\":1}}],[\"使用花括号初始化\",{\"1\":{\"43\":1}}],[\"使用\",{\"0\":{\"48\":1},\"1\":{\"43\":2}}],[\"使用圆括号初始化\",{\"1\":{\"43\":1}}],[\"使用显式型别初始化\",{\"0\":{\"41\":1}}],[\"使用写集\",{\"1\":{\"13\":1}}],[\"另外如果在遍历时使用了p的内存地址\",{\"1\":{\"40\":1}}],[\"匿名函数对象类型\",{\"1\":{\"40\":1}}],[\"<vector>\",{\"1\":{\"77\":3}}],[\"<vector>以及gadget\",{\"1\":{\"77\":1}}],[\"<string>\",{\"1\":{\"77\":4}}],[\"<<\",{\"1\":{\"61\":2,\"67\":4}}],[\"<class\",{\"1\":{\"52\":2}}],[\"<\",{\"1\":{\"40\":3}}],[\"用std\",{\"1\":{\"77\":1}}],[\"用户声明了其中一个不会影响自动生成另一个\",{\"1\":{\"61\":1}}],[\"用w做点事\",{\"1\":{\"52\":1}}],[\"用p做一些事\",{\"1\":{\"40\":1}}],[\"用于std\",{\"1\":{\"40\":1}}],[\"用来记录object被引用个数\",{\"1\":{\"65\":1}}],[\"用来保留完整的返回值类型\",{\"1\":{\"37\":1}}],[\"用来持久化保存对lsm的修改日志\",{\"1\":{\"24\":1}}],[\"用来持久化保存memtable修改日志\",{\"1\":{\"22\":1}}],[\"用来快速检索key是否存在\",{\"1\":{\"23\":1}}],[\"用来快速检索block\",{\"1\":{\"23\":1}}],[\"再例如\",{\"1\":{\"40\":1}}],[\"再执行完成后将执行结果以及证明πtx​广播给所有共识节点\",{\"1\":{\"11\":1}}],[\"第四章\",{\"0\":{\"62\":1}}],[\"第三章\",{\"0\":{\"42\":1}}],[\"第二章\",{\"0\":{\"39\":1}}],[\"第一章\",{\"0\":{\"27\":1}}],[\"略\",{\"1\":{\"38\":1,\"58\":1}}],[\"掌握查看型别推导结果的方法\",{\"0\":{\"38\":1}}],[\"只有声明\",{\"1\":{\"77\":1}}],[\"只有声明语句\",{\"1\":{\"77\":3}}],[\"只有控制块的内存仍然保持分配\",{\"1\":{\"76\":1}}],[\"只有编译器可见\",{\"1\":{\"40\":1}}],[\"只要用户声明了析构函数\",{\"1\":{\"61\":1}}],[\"只要其构造函数和其他成员函数都是constexpr修饰的\",{\"1\":{\"57\":1}}],[\"只要函数不抛出异常请使用\",{\"0\":{\"50\":1}}],[\"只需要检查该类的移动操作是否标记为noexcept即可\",{\"1\":{\"52\":1}}],[\"只能接收非右值类型的返回值\",{\"1\":{\"37\":1}}],[\"只保留值类型\",{\"1\":{\"32\":1}}],[\"等价形式\",{\"1\":{\"45\":3}}],[\"等号\",{\"1\":{\"43\":1}}],[\"等效于\",{\"1\":{\"37\":1}}],[\"等待被持久化为sstable文件\",{\"1\":{\"22\":1}}],[\"返回指向对象的std\",{\"1\":{\"63\":1}}],[\"返回它的副本\",{\"1\":{\"57\":1}}],[\"返回p相对于原点的镜像\",{\"1\":{\"57\":1}}],[\"返回到调用函数\",{\"1\":{\"51\":1}}],[\"返回widget\",{\"1\":{\"43\":1}}],[\"返回的是函数features返回值创建的临时std\",{\"1\":{\"41\":1}}],[\"返回\",{\"1\":{\"37\":4}}],[\"常用作返回值类型推导\",{\"1\":{\"37\":1}}],[\"yvalue\",{\"1\":{\"57\":4}}],[\"yval\",{\"1\":{\"57\":2}}],[\"y\",{\"1\":{\"37\":2,\"43\":2,\"57\":4}}],[\"例如离开了作用域\",{\"1\":{\"77\":1}}],[\"例如自定义析构函数\",{\"1\":{\"65\":1}}],[\"例如下例所示\",{\"1\":{\"61\":1}}],[\"例如c++98的遗留类型\",{\"1\":{\"60\":1}}],[\"例如由于widget类移动构造函数造成的\",{\"1\":{\"52\":1}}],[\"例如除零错误\",{\"1\":{\"51\":1}}],[\"例如容器类myalloclist中定义了分配器的类型type\",{\"1\":{\"45\":1}}],[\"例如想要创建一个包含10和20两个数的vector容器\",{\"1\":{\"43\":1}}],[\"例如本例中features\",{\"1\":{\"41\":1}}],[\"例如遍历一个哈希表m\",{\"1\":{\"40\":1}}],[\"例如\",{\"1\":{\"37\":1,\"40\":1,\"41\":1,\"43\":1,\"57\":1,\"63\":1,\"66\":1}}],[\"例如交易的输入参数\",{\"1\":{\"13\":1}}],[\"注意这里的继承\",{\"1\":{\"67\":1}}],[\"注意该控制块中的引用计数是1\",{\"1\":{\"67\":1}}],[\"注意decltype\",{\"1\":{\"37\":1}}],[\"注意如果推导传入的是右值则会去掉引用转换为常量值\",{\"1\":{\"37\":1}}],[\"注意wal和memtable是一对一的\",{\"1\":{\"22\":1}}],[\"的数据成员们移动到实现类\",{\"1\":{\"77\":1}}],[\"的指针\",{\"1\":{\"77\":1}}],[\"的内部成员中\",{\"1\":{\"67\":1}}],[\"的控制块指针\",{\"1\":{\"65\":1}}],[\"的裸指针和指向控制块\",{\"1\":{\"65\":1}}],[\"的\",{\"1\":{\"53\":1}}],[\"的同义词\",{\"1\":{\"45\":1}}],[\"的类型\",{\"1\":{\"36\":2}}],[\"的算法分别如上所示\",{\"1\":{\"13\":1}}],[\"不然会内存泄漏\",{\"1\":{\"77\":1}}],[\"不适用\",{\"0\":{\"73\":1}}],[\"不幸的是第2步执行computepriority时发生了异常\",{\"1\":{\"71\":1}}],[\"不使用make函数\",{\"1\":{\"69\":2}}],[\"不管makeinvestment实际创建的什么类型的对象\",{\"1\":{\"63\":1}}],[\"不能被复制只能移动\",{\"1\":{\"63\":1}}],[\"不能处理异常的函数会直接退出\",{\"1\":{\"51\":1}}],[\"不能推导\",{\"1\":{\"36\":2}}],[\"不能推导出t\",{\"1\":{\"36\":1}}],[\"不可修改的memtable列表持久化成sstable的l0层\",{\"1\":{\"21\":1}}],[\"不可修改的memtable列表\",{\"1\":{\"21\":1}}],[\"形参声明的模板\",{\"1\":{\"36\":1}}],[\"9\",{\"1\":{\"36\":3,\"57\":1}}],[\"是暗含inline属性的\",{\"1\":{\"77\":1}}],[\"是可以省略的\",{\"1\":{\"48\":1}}],[\"是一种特殊的用法\",{\"1\":{\"37\":1}}],[\"是vector<int>\",{\"1\":{\"37\":1}}],[\"是widget\",{\"1\":{\"37\":1}}],[\"是int\",{\"1\":{\"37\":3}}],[\"是bool\",{\"1\":{\"37\":2}}],[\"是const\",{\"1\":{\"37\":2}}],[\"是auto型别推导和模板型别推导唯一不同之处\",{\"1\":{\"36\":1}}],[\"是否可序列化\",{\"1\":{\"21\":1}}],[\"是否开启wal\",{\"1\":{\"21\":1}}],[\"无法推导std\",{\"1\":{\"36\":1}}],[\"错误信息自身往往指向对象w被创建的那行\",{\"1\":{\"77\":1}}],[\"错误的原因在于当对象w被析构时\",{\"1\":{\"77\":1}}],[\"错误\",{\"1\":{\"36\":4,\"43\":2,\"46\":2,\"47\":3,\"55\":3,\"77\":1}}],[\"0\",{\"1\":{\"36\":1,\"37\":6,\"43\":10,\"44\":1,\"57\":2,\"61\":3}}],[\"3\",{\"1\":{\"36\":5,\"43\":3,\"47\":1,\"56\":1,\"57\":1,\"67\":1}}],[\"值是\",{\"1\":{\"36\":1}}],[\"值是27\",{\"1\":{\"36\":1}}],[\"值类型推导\",{\"1\":{\"35\":1}}],[\"初始化constexpr对象\",{\"1\":{\"57\":1}}],[\"初始化和大括号\",{\"1\":{\"43\":1}}],[\"初始化\",{\"0\":{\"36\":1},\"1\":{\"43\":3}}],[\"初始化sstable对象\",{\"1\":{\"23\":1}}],[\"引用计数增加\",{\"1\":{\"67\":1}}],[\"引用计数\",{\"0\":{\"65\":1},\"1\":{\"65\":1,\"68\":1}}],[\"引用限定符的用法于const限定类似\",{\"1\":{\"48\":1}}],[\"引用限定符是c++11引入的特性\",{\"1\":{\"48\":1}}],[\"引用折叠\",{\"1\":{\"35\":1}}],[\"引用类型推导\",{\"1\":{\"35\":1}}],[\"理解特种函数的生成机制\",{\"0\":{\"59\":1}}],[\"理解decltype\",{\"0\":{\"37\":1}}],[\"理解\",{\"0\":{\"34\":1}}],[\"理解模板型别推导\",{\"0\":{\"28\":1}}],[\"传递const\",{\"1\":{\"32\":1}}],[\"仍然以传值的方式处理param\",{\"1\":{\"32\":1}}],[\"则可能无法创建出对应的类型\",{\"1\":{\"75\":1}}],[\"则只能采用new构造形式\",{\"1\":{\"74\":1}}],[\"则没有类似的问题\",{\"1\":{\"71\":1}}],[\"则bp1和bp2指向相同的对象\",{\"1\":{\"67\":1}}],[\"则该对象自动被析构\",{\"1\":{\"65\":1}}],[\"则该函数退化为普通函数\",{\"1\":{\"56\":1}}],[\"则对应对象的引用计数减1\",{\"1\":{\"65\":1}}],[\"则sp1原来指向对象的引用计数减1\",{\"1\":{\"65\":1}}],[\"则二者指向对象的引用计数加1\",{\"1\":{\"65\":1}}],[\"则应该同时声明所有的这三个\",{\"1\":{\"61\":1}}],[\"则输出\",{\"1\":{\"61\":1}}],[\"则不会生成移动操作函数\",{\"1\":{\"61\":1}}],[\"则不允许调用该类的复制赋值函数\",{\"1\":{\"61\":1}}],[\"则编译器不允许调用该类的复制构造\",{\"1\":{\"61\":1}}],[\"则自动生成的复制构造函数将被会标记为delete\",{\"1\":{\"61\":1}}],[\"则生成的析构函数也是虚函数\",{\"1\":{\"61\":1}}],[\"则会调用其复制构造函数\",{\"1\":{\"60\":1}}],[\"则会去掉指针本身的const\",{\"1\":{\"32\":1}}],[\"则其执行结果也是编译器已知的\",{\"1\":{\"56\":1}}],[\"则使用移动操作可能会出现问题\",{\"1\":{\"52\":1}}],[\"则表明this对象指向着右值对象\",{\"1\":{\"48\":1}}],[\"则表明this对象指向着左值对象\",{\"1\":{\"48\":1}}],[\"则decltype\",{\"1\":{\"43\":1}}],[\"则这个地址是指向复制后的临时变量\",{\"1\":{\"40\":1}}],[\"则\",{\"1\":{\"33\":2}}],[\"则推导过程与上述过程类似\",{\"1\":{\"30\":1}}],[\"既非指针也非引用\",{\"0\":{\"32\":1}}],[\"推导过程参考引用折叠\",{\"1\":{\"31\":1}}],[\"推导过程也是类似\",{\"1\":{\"30\":1}}],[\"=v\",{\"1\":{\"40\":1}}],[\"==\",{\"1\":{\"37\":1}}],[\"=\",{\"1\":{\"30\":5,\"32\":1,\"33\":1,\"35\":3,\"36\":8,\"37\":6,\"40\":5,\"41\":2,\"43\":8,\"45\":3,\"46\":5,\"47\":7,\"48\":1,\"49\":1,\"55\":3,\"56\":1,\"57\":7,\"61\":10,\"63\":3,\"66\":3,\"67\":2,\"68\":4,\"72\":1,\"74\":1,\"75\":2,\"76\":1,\"77\":7}}],[\"xvalue\",{\"1\":{\"57\":4}}],[\"xval\",{\"1\":{\"57\":2}}],[\"x初始值为0\",{\"1\":{\"43\":1}}],[\"x的类型是std\",{\"1\":{\"36\":1}}],[\"x5\",{\"1\":{\"36\":1}}],[\"x4初始化为27\",{\"1\":{\"36\":1}}],[\"x4\",{\"1\":{\"36\":2}}],[\"x3\",{\"1\":{\"36\":3}}],[\"x2\",{\"1\":{\"36\":3}}],[\"x1\",{\"1\":{\"36\":2}}],[\"xx\",{\"1\":{\"35\":3}}],[\"x\",{\"1\":{\"30\":8,\"32\":1,\"36\":1,\"37\":6,\"43\":2,\"48\":11,\"52\":2,\"57\":4}}],[\"x是int\",{\"1\":{\"30\":1}}],[\"x=27\",{\"1\":{\"30\":1,\"32\":1}}],[\"变量定义\",{\"1\":{\"30\":1}}],[\"保证\",{\"0\":{\"58\":1}}],[\"保留指针指向对象的const\",{\"1\":{\"32\":1}}],[\"保留const\",{\"1\":{\"30\":1}}],[\"保存每个sstable\",{\"1\":{\"21\":1}}],[\"保存每一层对应的sstable\",{\"1\":{\"21\":1}}],[\"忽略引用部分\",{\"1\":{\"30\":1}}],[\"如析构函数\",{\"1\":{\"77\":1}}],[\"如下图所示\",{\"1\":{\"68\":1}}],[\"如下例所示\",{\"1\":{\"61\":1,\"66\":1,\"68\":1,\"75\":1}}],[\"如下所示\",{\"1\":{\"57\":1}}],[\"如之前一样\",{\"1\":{\"30\":3,\"32\":3}}],[\"如果将unique\",{\"1\":{\"77\":1}}],[\"如果按以下方式实现\",{\"1\":{\"77\":1}}],[\"如果按照上述的写法则会发生std\",{\"1\":{\"40\":1}}],[\"如果上述pimpl类修改为如下则会发生错误\",{\"1\":{\"77\":1}}],[\"如果改成pimpl的形式则不会存在这个问题\",{\"1\":{\"77\":1}}],[\"如果一个头文件的内容变了\",{\"1\":{\"77\":1}}],[\"如果类的构造函数存在重载\",{\"1\":{\"75\":1}}],[\"如果智能指针需要使用自定义构造器\",{\"1\":{\"74\":1}}],[\"如果b使用shared\",{\"1\":{\"68\":1}}],[\"如果wpw过期\",{\"1\":{\"68\":1}}],[\"如果没有则创建一个新的\",{\"1\":{\"67\":1}}],[\"如果有则直接返回一个新的\",{\"1\":{\"67\":1}}],[\"如果\",{\"1\":{\"67\":1}}],[\"如果引用计数减为0\",{\"1\":{\"65\":1}}],[\"如果sp1或者sp2超出作用域\",{\"1\":{\"65\":1}}],[\"如果sp1使用sp2进行初始化\",{\"1\":{\"65\":1}}],[\"如果用户声明了复制构造函数\",{\"1\":{\"61\":1}}],[\"如果取消移动构造函数注释\",{\"1\":{\"61\":1}}],[\"如果该类中声明了复制构造函数\",{\"1\":{\"61\":1}}],[\"如果该类声明了移动操作函数\",{\"1\":{\"61\":1}}],[\"如果非静态成员类别为不可移动类别\",{\"1\":{\"60\":1}}],[\"如果需要声明为可能抛出异常\",{\"1\":{\"53\":1}}],[\"如果在运行时f出现异常\",{\"1\":{\"52\":1}}],[\"如果在该临时变量析构后访问可能会导致潜在的内存错误\",{\"1\":{\"40\":1}}],[\"如果异常没有被处理\",{\"1\":{\"51\":1}}],[\"如果异常被成功处理\",{\"1\":{\"51\":1}}],[\"如果想让普通函数不接受某些类别的形参进行隐式转换或者模板函数的某种实例化函数被调用\",{\"1\":{\"47\":1}}],[\"如果使用new运算符\",{\"1\":{\"71\":1}}],[\"如果使用大括号\",{\"1\":{\"43\":1}}],[\"如果使用小括号\",{\"1\":{\"43\":1}}],[\"如果使用c++14可以进一步简化为\",{\"1\":{\"40\":1}}],[\"如果auto推导不符合预期\",{\"0\":{\"41\":1}}],[\"如果不使用auto可能会写成如下\",{\"1\":{\"40\":1}}],[\"如果传入的是函数类型\",{\"1\":{\"33\":1}}],[\"如果传入的是数组类型\",{\"1\":{\"33\":1}}],[\"如果传入的是一个指针\",{\"1\":{\"32\":1}}],[\"如果param是一个指针\",{\"1\":{\"30\":1}}],[\"如果paramtype带有const\",{\"1\":{\"30\":1}}],[\"如果expr的类型是一个引用\",{\"1\":{\"30\":1}}],[\"如上图所示\",{\"1\":{\"13\":1}}],[\"类widget使用者也必须要重新编译\",{\"1\":{\"77\":1}}],[\"类widget的定义如下\",{\"1\":{\"77\":1}}],[\"类型\",{\"1\":{\"44\":1}}],[\"类型是std\",{\"1\":{\"36\":1}}],[\"类型是int\",{\"1\":{\"36\":1}}],[\"类型是void\",{\"1\":{\"33\":3}}],[\"类型推导\",{\"0\":{\"34\":1}}],[\"类型推导会去除传入参数的所有属性\",{\"1\":{\"32\":1}}],[\"类型推导会这样进行\",{\"1\":{\"30\":1}}],[\"类似于矿工节点\",{\"1\":{\"8\":1}}],[\"函数computepriority用来计算优先级\",{\"1\":{\"71\":1}}],[\"函数processwidget按照某种优先级处理widget\",{\"1\":{\"71\":1}}],[\"函数调用\",{\"1\":{\"30\":1}}],[\"函数的形式如下\",{\"1\":{\"30\":1,\"31\":1,\"32\":1}}],[\"函数模板形式\",{\"0\":{\"29\":1}}],[\"为1\",{\"1\":{\"68\":1}}],[\"为此widget对象分配数据成员\",{\"1\":{\"77\":1}}],[\"为此\",{\"1\":{\"63\":1}}],[\"为什么要加上\",{\"0\":{\"52\":1}}],[\"为了能正确处理异常\",{\"1\":{\"51\":1}}],[\"为了保证交易的及时处理\",{\"1\":{\"13\":1}}],[\"为std\",{\"1\":{\"43\":1}}],[\"为万能引用\",{\"0\":{\"31\":1}}],[\"为指针或者引用\",{\"0\":{\"30\":1}}],[\"阅读笔记\",{\"1\":{\"27\":1,\"39\":1,\"42\":1,\"62\":1}}],[\"型别推导\",{\"0\":{\"27\":1,\"35\":1}}],[\"向manifest文件中添加一条manifestrecord\",{\"1\":{\"25\":1}}],[\"向wal日志中添加修改记录\",{\"1\":{\"24\":1}}],[\"j\",{\"1\":{\"33\":1}}],[\"json\",{\"1\":{\"25\":1}}],[\"joinhandle<\",{\"1\":{\"21\":2}}],[\"执行computepriority\",{\"1\":{\"71\":2}}],[\"执行过compaction的所有sstable\",{\"1\":{\"25\":1}}],[\"执行交易\",{\"1\":{\"8\":1}}],[\"创建std\",{\"1\":{\"76\":2}}],[\"创建的分别是指向一个包含10个元素\",{\"1\":{\"75\":1}}],[\"创建智能指针的方式有两种\",{\"1\":{\"69\":1}}],[\"创建后的weak\",{\"1\":{\"68\":1}}],[\"创建完成后请不要再使用裸指针\",{\"1\":{\"65\":1}}],[\"创建完成后unique\",{\"1\":{\"65\":1}}],[\"创建non\",{\"1\":{\"57\":1}}],[\"创建基类指针指向派生类对象\",{\"1\":{\"48\":1}}],[\"创建包含两个元素的std\",{\"1\":{\"43\":1}}],[\"创建一个大对象\",{\"1\":{\"76\":1}}],[\"创建一个包含10个元素的std\",{\"1\":{\"43\":1}}],[\"创建一个新的manifest文件\",{\"1\":{\"25\":1}}],[\"创建对象\",{\"0\":{\"43\":1}}],[\"创建过的所有memtable\",{\"1\":{\"25\":1}}],[\"创建wal文件\",{\"1\":{\"24\":1}}],[\"创建带有wal的memtable\",{\"1\":{\"22\":1}}],[\"这让编译器有可能生成更小的运行时数据结构和更快的运行代码\",{\"1\":{\"77\":1}}],[\"这些错误信息只在对象w销毁的地方出现\",{\"1\":{\"77\":1}}],[\"这些头文件将会增加类widget使用者的编译时间\",{\"1\":{\"77\":1}}],[\"这通常是错误信息的来源\",{\"1\":{\"77\":1}}],[\"这会使得a和b相互引用\",{\"1\":{\"68\":1}}],[\"这会占用一定的空间同时也会屏蔽部分优化\",{\"1\":{\"51\":1}}],[\"这带来的问题就是weak\",{\"1\":{\"68\":1}}],[\"这就导致会出现double\",{\"1\":{\"67\":1}}],[\"这意味着我们通过基类指针删除派生类实例\",{\"1\":{\"63\":1}}],[\"这类函数自身不抛出异常\",{\"1\":{\"53\":1}}],[\"这种多样性可能会导致一些误解\",{\"1\":{\"43\":1}}],[\"这个是函数\",{\"1\":{\"41\":2}}],[\"这样保证存储引擎宕机时不会发生数据的丢失\",{\"1\":{\"24\":1}}],[\"这里定义\",{\"1\":{\"77\":1}}],[\"这里非常重要\",{\"1\":{\"77\":1}}],[\"这里\",{\"1\":{\"48\":1}}],[\"这里使用typename主要是因为\",{\"1\":{\"45\":1}}],[\"这里应该进行显式转换\",{\"1\":{\"41\":1}}],[\"这里面derefless变量的类型是一个不可命名的\",{\"1\":{\"40\":1}}],[\"这里举个例子\",{\"1\":{\"30\":1,\"52\":1}}],[\"这里提供了提议节点完成的执行流程的例子\",{\"1\":{\"13\":1}}],[\"这里不过多介绍\",{\"1\":{\"13\":1}}],[\"这里的窗口大小设置为k\",{\"1\":{\"13\":1}}],[\"之后才会被提交到lsm结构修改\",{\"1\":{\"24\":1}}],[\"查找等函数\",{\"1\":{\"61\":1}}],[\"查找key所在的block索引\",{\"1\":{\"23\":1}}],[\"查询操作包括单点查询和范围查询\",{\"1\":{\"19\":1}}],[\"根据wal日志恢复memtable\",{\"1\":{\"24\":1}}],[\"根据block索引从block\",{\"1\":{\"23\":1}}],[\"根据窗口内区块写集构建的不完全状态\",{\"1\":{\"13\":1}}],[\"打开ssatble文件\",{\"1\":{\"23\":1}}],[\"末尾位置\",{\"1\":{\"23\":1}}],[\"起始位置\",{\"1\":{\"23\":1}}],[\"序列化后的offset\",{\"1\":{\"23\":1}}],[\"序列化后的data\",{\"1\":{\"23\":1}}],[\"16\",{\"1\":{\"57\":1}}],[\"19\",{\"1\":{\"57\":1}}],[\"1998\",{\"1\":{\"49\":1}}],[\"1983\",{\"1\":{\"49\":1}}],[\"10是\",{\"1\":{\"55\":1}}],[\"10\",{\"1\":{\"43\":3,\"55\":1,\"75\":2}}],[\"11\",{\"1\":{\"36\":3}}],[\"13\",{\"1\":{\"33\":2}}],[\"1\",{\"1\":{\"23\":3,\"24\":1,\"25\":1,\"36\":5,\"43\":2,\"57\":1,\"67\":2}}],[\"12\",{\"1\":{\"13\":1}}],[\"可能悬空时使用\",{\"0\":{\"68\":1}}],[\"可能会采用的做法是\",{\"1\":{\"67\":1}}],[\"可能会导致未定义的行为\",{\"1\":{\"52\":1}}],[\"可能不会被编译\",{\"1\":{\"44\":1}}],[\"可以进一步实现一个接收constexpr的point对象\",{\"1\":{\"57\":1}}],[\"可以采用delete关键字\",{\"1\":{\"47\":1}}],[\"可以接收任意类型的返回值\",{\"1\":{\"37\":1}}],[\"可以视为key\",{\"1\":{\"23\":1}}],[\"可以视为block的索引\",{\"1\":{\"23\":1}}],[\"可修改的mutable和不可修改的immutable\",{\"1\":{\"22\":1}}],[\"dowork\",{\"1\":{\"48\":3}}],[\"double\",{\"1\":{\"33\":4,\"47\":1,\"57\":7}}],[\"dwim\",{\"1\":{\"40\":1}}],[\"data2\",{\"1\":{\"55\":1}}],[\"data1\",{\"1\":{\"55\":1}}],[\"data\",{\"1\":{\"23\":6,\"55\":1,\"77\":4}}],[\"delinvmt\",{\"1\":{\"63\":3}}],[\"deleted\",{\"1\":{\"61\":2}}],[\"delete\",{\"1\":{\"17\":1,\"47\":7,\"63\":1,\"66\":1,\"77\":1}}],[\"destroying\",{\"1\":{\"61\":1}}],[\"design\",{\"0\":{\"7\":1}}],[\"default\",{\"1\":{\"61\":9,\"77\":6}}],[\"derived\",{\"1\":{\"48\":1}}],[\"derefless\",{\"1\":{\"40\":1}}],[\"derefupless\",{\"1\":{\"40\":2}}],[\"decltype类型推导\",{\"1\":{\"37\":1}}],[\"decltype\",{\"1\":{\"37\":14,\"63\":1,\"66\":1,\"74\":1}}],[\"decltype在推导时会保留完整类型\",{\"1\":{\"37\":1}}],[\"decode\",{\"1\":{\"23\":2}}],[\"|\",{\"1\":{\"23\":33,\"24\":11,\"25\":8}}],[\"范围检索\",{\"1\":{\"22\":1}}],[\"范围查询的关键是通过单点查询获取其起始边界的位置\",{\"1\":{\"19\":1}}],[\"use\",{\"1\":{\"61\":2}}],[\"using会比typedef要方便许多\",{\"1\":{\"45\":1}}],[\"using\",{\"1\":{\"45\":3}}],[\"usize\",{\"1\":{\"21\":4,\"22\":3,\"23\":6,\"25\":2}}],[\"upv\",{\"1\":{\"75\":1}}],[\"upw2\",{\"1\":{\"69\":1}}],[\"upw1\",{\"1\":{\"69\":1}}],[\"upw\",{\"1\":{\"66\":1,\"74\":1}}],[\"upb\",{\"1\":{\"48\":2}}],[\"uptrmapss\",{\"1\":{\"45\":2}}],[\"upper\",{\"1\":{\"22\":1}}],[\"undefined\",{\"1\":{\"52\":1,\"65\":1}}],[\"unwinding\",{\"1\":{\"51\":1}}],[\"unordered\",{\"1\":{\"40\":1,\"45\":2}}],[\"unique<impl>\",{\"1\":{\"77\":3}}],[\"unique<std\",{\"1\":{\"75\":1}}],[\"unique<widget>\",{\"1\":{\"69\":1}}],[\"unique<derived>\",{\"1\":{\"48\":1}}],[\"unique只是将参数包完美转发到索要创建的对象的构造函数中\",{\"1\":{\"69\":1}}],[\"unique相反\",{\"1\":{\"64\":1}}],[\"unique\",{\"1\":{\"40\":7,\"45\":2,\"48\":1,\"63\":9,\"65\":1,\"66\":4,\"69\":4,\"74\":1,\"77\":12}}],[\"u64\",{\"1\":{\"23\":3}}],[\"u32\",{\"1\":{\"23\":1}}],[\"u8\",{\"1\":{\"22\":1,\"23\":2,\"24\":1}}],[\"获取key对应的值\",{\"1\":{\"22\":1}}],[\"从裸指针出发初始化std\",{\"1\":{\"65\":1}}],[\"从std\",{\"1\":{\"65\":1}}],[\"从c++14开始\",{\"1\":{\"56\":1}}],[\"从manifest文件中恢复得到manifestrecord列表\",{\"1\":{\"25\":1}}],[\"从字节数组反序列化得到block对象\",{\"1\":{\"23\":1}}],[\"从wal文件中恢复memtable\",{\"1\":{\"22\":1}}],[\"从而破坏了系统的安全性和稳健性\",{\"1\":{\"6\":1}}],[\"构造函数匹配问题\",{\"0\":{\"75\":1}}],[\"构造函数\",{\"1\":{\"22\":1,\"23\":1,\"24\":1,\"25\":1}}],[\"跳表预估占用内存大小\",{\"1\":{\"22\":1}}],[\"跳表id\",{\"1\":{\"22\":1}}],[\"线程安全跳表\",{\"1\":{\"22\":1}}],[\"实现在下面\",{\"1\":{\"56\":1}}],[\"实现结构为线程安全的跳表\",{\"1\":{\"22\":1}}],[\"实际上是派生类的dowork函数被调用\",{\"1\":{\"48\":1}}],[\"实际上还有一些附加的信息\",{\"1\":{\"23\":1}}],[\"实际的交易执行内容\",{\"1\":{\"9\":1}}],[\"free的情况\",{\"1\":{\"67\":1}}],[\"free问题的高发地\",{\"1\":{\"65\":1}}],[\"from\",{\"1\":{\"22\":1,\"67\":6}}],[\"false\",{\"1\":{\"46\":2,\"53\":1}}],[\"fp\",{\"1\":{\"45\":2}}],[\"features\",{\"1\":{\"41\":4}}],[\"found\",{\"1\":{\"78\":1}}],[\"forward<ts>\",{\"1\":{\"63\":3,\"69\":1}}],[\"for语句等\",{\"1\":{\"56\":1}}],[\"for\",{\"1\":{\"40\":1}}],[\"foo2\",{\"1\":{\"48\":1}}],[\"foo1\",{\"1\":{\"48\":1}}],[\"foo\",{\"1\":{\"37\":1,\"48\":8}}],[\"f2\",{\"1\":{\"33\":3}}],[\"f1\",{\"1\":{\"33\":3}}],[\"function\",{\"1\":{\"52\":3,\"61\":2}}],[\"function对象本身占用空间\",{\"1\":{\"40\":1}}],[\"function<bool\",{\"1\":{\"40\":1}}],[\"function来实现\",{\"1\":{\"40\":1}}],[\"fun\",{\"1\":{\"32\":1}}],[\"f\",{\"1\":{\"29\":2,\"30\":11,\"31\":1,\"32\":6,\"36\":4,\"37\":4,\"44\":5,\"52\":2}}],[\"find\",{\"1\":{\"23\":1,\"49\":1}}],[\"fileobject\",{\"1\":{\"23\":2}}],[\"file\",{\"1\":{\"23\":2,\"24\":1,\"25\":1}}],[\"filters\",{\"1\":{\"21\":1}}],[\"first\",{\"1\":{\"23\":2,\"52\":2}}],[\"fn\",{\"1\":{\"22\":7,\"23\":7,\"24\":3,\"25\":3}}],[\"flush线程\",{\"1\":{\"21\":1}}],[\"flush\",{\"1\":{\"21\":2,\"22\":1,\"25\":1}}],[\"通过new创建大对象\",{\"1\":{\"76\":1}}],[\"通过std\",{\"1\":{\"76\":1,\"77\":1}}],[\"通过基类指针调用dowork\",{\"1\":{\"48\":1}}],[\"通过共识协议维护一致的账本视图\",{\"1\":{\"8\":1}}],[\"通常用json格式保存\",{\"1\":{\"25\":1}}],[\"通知compaction线程停止\",{\"1\":{\"21\":1}}],[\"通知flush线程停止\",{\"1\":{\"21\":1}}],[\"主要提供高效的数据检索和修改\",{\"1\":{\"22\":1}}],[\"主要为上层提供操作接口\",{\"1\":{\"21\":1}}],[\"主要负责对存储状态的修改\",{\"1\":{\"21\":1}}],[\"下一个sstable的id\",{\"1\":{\"21\":1}}],[\"压实\",{\"1\":{\"21\":1}}],[\">getptr\",{\"1\":{\"67\":2}}],[\">dowork\",{\"1\":{\"48\":1}}],[\">>>\",{\"1\":{\"21\":2}}],[\">\",{\"1\":{\"21\":4,\"22\":10,\"23\":7,\"24\":4,\"25\":6,\"40\":1,\"56\":1,\"63\":1,\"66\":1,\"74\":1}}],[\"按顺序存储\",{\"1\":{\"21\":2}}],[\"按照从新到旧的顺序在memtable\",{\"1\":{\"19\":1}}],[\"包含对象和控制块\",{\"1\":{\"72\":1}}],[\"包含交易的输入以及客户端的数字签名\",{\"1\":{\"11\":1}}],[\"包括圆括号\",{\"1\":{\"43\":1}}],[\"包括memtable\",{\"1\":{\"21\":1}}],[\"bp2\",{\"1\":{\"67\":1}}],[\"bp1\",{\"1\":{\"67\":2}}],[\"behavior和double\",{\"1\":{\"65\":1}}],[\"behavior\",{\"1\":{\"52\":1}}],[\"bad\",{\"1\":{\"67\":3}}],[\"back的过程中抛出异常\",{\"1\":{\"52\":1}}],[\"back的操作一种显然的优化思路是将复制操作改为移动操作\",{\"1\":{\"52\":1}}],[\"back\",{\"1\":{\"52\":1}}],[\"base\",{\"1\":{\"48\":2,\"56\":1}}],[\"bar\",{\"1\":{\"37\":3}}],[\"b\",{\"1\":{\"40\":3,\"52\":2,\"68\":1}}],[\"briggs\",{\"1\":{\"33\":1}}],[\"buf\",{\"1\":{\"23\":2}}],[\"builder\",{\"1\":{\"22\":1}}],[\"bytes>\",{\"1\":{\"24\":1}}],[\"bytes>>\",{\"1\":{\"22\":1}}],[\"bytes\",{\"1\":{\"23\":1}}],[\"bond\",{\"1\":{\"63\":2}}],[\"bound<keyslice>\",{\"1\":{\"22\":2}}],[\"bool\",{\"1\":{\"21\":2,\"37\":1,\"41\":1,\"44\":1,\"47\":5}}],[\"black\",{\"1\":{\"46\":4}}],[\"bloom\",{\"1\":{\"23\":1}}],[\"bloom过滤器\",{\"1\":{\"23\":1}}],[\"block中的最后一个key\",{\"1\":{\"23\":1}}],[\"block中的第一个key\",{\"1\":{\"23\":1}}],[\"block的在sstable中的偏移\",{\"1\":{\"23\":1}}],[\"block的结构体\",{\"1\":{\"23\":1}}],[\"block的结构\",{\"1\":{\"23\":1}}],[\"blockmeta相关的方法\",{\"1\":{\"23\":1}}],[\"blockmeta\",{\"1\":{\"23\":2}}],[\"blockmeta保存的是对应block的元数据信息\",{\"1\":{\"23\":1}}],[\"block相关的方法\",{\"1\":{\"23\":1}}],[\"block大小\",{\"1\":{\"21\":1}}],[\"block\",{\"1\":{\"8\":2,\"21\":2,\"23\":15,\"65\":1}}],[\"blockchain\",{\"1\":{\"5\":1}}],[\"blk​\",{\"1\":{\"9\":1}}],[\"n>\",{\"1\":{\"52\":1}}],[\"null\",{\"1\":{\"44\":1}}],[\"nullptr可以隐式转换成普通指针\",{\"1\":{\"44\":1}}],[\"nullptr\",{\"1\":{\"44\":1,\"63\":1,\"68\":1}}],[\"null和nullptr最大的区别是null的类型是int\",{\"1\":{\"44\":1}}],[\"numconds\",{\"1\":{\"56\":2}}],[\"number\",{\"1\":{\"47\":1}}],[\"num\",{\"1\":{\"21\":1,\"23\":1}}],[\"name的类型是const\",{\"1\":{\"33\":1}}],[\"name\",{\"1\":{\"33\":3,\"77\":4}}],[\"netural\",{\"1\":{\"53\":1}}],[\"new\",{\"1\":{\"63\":3,\"66\":4,\"67\":2,\"69\":3,\"71\":3,\"72\":1,\"74\":2,\"76\":1,\"77\":1}}],[\"newy\",{\"1\":{\"57\":2}}],[\"newx\",{\"1\":{\"57\":2}}],[\"newvalue\",{\"1\":{\"36\":2}}],[\"newmemtable\",{\"1\":{\"25\":1}}],[\"next\",{\"1\":{\"21\":1}}],[\"n\",{\"1\":{\"23\":2,\"52\":2}}],[\"not\",{\"1\":{\"78\":1}}],[\"notifier\",{\"1\":{\"21\":2}}],[\"non\",{\"1\":{\"55\":1}}],[\"noexcept\",{\"1\":{\"52\":7,\"56\":1,\"57\":7,\"61\":5}}],[\"node\",{\"1\":{\"8\":2}}],[\"以及指向它的指针\",{\"1\":{\"77\":1}}],[\"以上将x1\",{\"1\":{\"36\":1}}],[\"以引用的方式处理param\",{\"1\":{\"33\":1}}],[\"以传值的方式处理param\",{\"1\":{\"32\":1,\"33\":1}}],[\"以便在系统重启的时候能够恢复到正常的状态\",{\"1\":{\"25\":1}}],[\"以字节为单位\",{\"1\":{\"21\":1}}],[\"以保持lsm\",{\"1\":{\"18\":1}}],[\"字节为单位\",{\"1\":{\"21\":1}}],[\"二\",{\"1\":{\"20\":1,\"39\":1}}],[\"二者的根节点一致\",{\"1\":{\"13\":1}}],[\"当使用pimpl惯用法\",{\"0\":{\"77\":1}}],[\"当对象的引用计数降为0\",{\"1\":{\"76\":1}}],[\"当\",{\"0\":{\"68\":1}}],[\"当类中不包含用户声明的析构函数时生成\",{\"1\":{\"61\":1}}],[\"当然对于移动构造函数来说\",{\"1\":{\"60\":1}}],[\"当然这里的闭包可以用std\",{\"1\":{\"40\":1}}],[\"当程序找到可以处理异常的函数func时\",{\"1\":{\"51\":1}}],[\"当mutable的大小达到上限后会被冻结为immutable\",{\"1\":{\"22\":1}}],[\"当mem\",{\"1\":{\"18\":1}}],[\"当前的可修改的memtable\",{\"1\":{\"21\":1}}],[\"当前区块交易merkle树的根节点\",{\"1\":{\"9\":1}}],[\"当某一层sst满了之后进行压缩合并至下一层的sstable\",{\"1\":{\"18\":1}}],[\"后者用来记录有多少shared\",{\"1\":{\"76\":1}}],[\"后文有介绍\",{\"1\":{\"65\":1}}],[\"后文简称immutable\",{\"1\":{\"17\":1}}],[\"后文简称参与节点\",{\"1\":{\"8\":1}}],[\"后文简称提议节点\",{\"1\":{\"8\":1}}],[\"后台compact线程\",{\"1\":{\"18\":1}}],[\"后台flush线程\",{\"1\":{\"18\":1}}],[\"到这一步用户线程操作结束\",{\"1\":{\"18\":1}}],[\"预写日志\",{\"1\":{\"18\":1}}],[\"预写日志文件\",{\"1\":{\"17\":1}}],[\"事务处理等\",{\"1\":{\"21\":1}}],[\"事务操作\",{\"1\":{\"17\":1}}],[\"事务读写集是否满足序列化\",{\"1\":{\"13\":1}}],[\"g3\",{\"1\":{\"77\":4}}],[\"g2\",{\"1\":{\"77\":4}}],[\"g1\",{\"1\":{\"77\":4}}],[\"gadget是用户自定义的类型\",{\"1\":{\"77\":1}}],[\"gadget\",{\"1\":{\"77\":7}}],[\"gp2\",{\"1\":{\"67\":1}}],[\"gp1\",{\"1\":{\"67\":2}}],[\"good\",{\"1\":{\"67\":3}}],[\"getptr\",{\"1\":{\"67\":2}}],[\"get\",{\"1\":{\"17\":1,\"22\":1}}],[\"github\",{\"1\":{\"16\":2}}],[\"存储引擎一般会提供一下接口\",{\"1\":{\"17\":1}}],[\"存储节点收到区块后会按照交易的顺序将其写集提交至底层账本\",{\"1\":{\"13\":1}}],[\"存储节点收到后在本地执行\",{\"1\":{\"11\":1}}],[\"存储节点和共识节点均维护有一个相同结构的状态树\",{\"1\":{\"13\":1}}],[\"存储节点的执行过程在tee\",{\"1\":{\"12\":1}}],[\"存储节点交易执行流程\",{\"0\":{\"12\":1}}],[\"存储节点发现区块已经生成后\",{\"1\":{\"11\":1}}],[\"存储节点\",{\"1\":{\"8\":1}}],[\"磁盘中分层有序key\",{\"1\":{\"17\":1}}],[\"assert检查会失败\",{\"1\":{\"77\":1}}],[\"assert来确保原始指针指向的类型不是一个不完整类型\",{\"1\":{\"77\":1}}],[\"asref<path>\",{\"1\":{\"22\":2,\"24\":2,\"25\":2}}],[\"a和c共享b的所有权\",{\"1\":{\"68\":1}}],[\"a\",{\"1\":{\"47\":1,\"52\":2,\"61\":34}}],[\"ai3\",{\"1\":{\"43\":1}}],[\"ai2\",{\"1\":{\"43\":1}}],[\"ai1\",{\"1\":{\"43\":1}}],[\"atomic<int>\",{\"1\":{\"43\":3}}],[\"atomicusize\",{\"1\":{\"21\":1}}],[\"arguments\",{\"1\":{\"63\":2}}],[\"arraysize值在编译期不可知\",{\"1\":{\"55\":1}}],[\"arraysize>\",{\"1\":{\"55\":1}}],[\"arraysize是sz的const复制\",{\"1\":{\"55\":1}}],[\"arraysize\",{\"1\":{\"55\":1}}],[\"arraysize2是constexpr\",{\"1\":{\"55\":1}}],[\"arraysize2>\",{\"1\":{\"55\":1}}],[\"arraysize2\",{\"1\":{\"55\":1}}],[\"arraysize1\",{\"1\":{\"55\":1}}],[\"array<int\",{\"1\":{\"55\":3,\"56\":1}}],[\"arr\",{\"1\":{\"37\":4}}],[\"arc<atomicusize>\",{\"1\":{\"22\":1}}],[\"arc<skipmap<keybytes\",{\"1\":{\"22\":1}}],[\"arc<sstable>>\",{\"1\":{\"21\":1}}],[\"arc<lsmstorageinner>\",{\"1\":{\"21\":1}}],[\"arc<lsmstorageoptions>\",{\"1\":{\"21\":1}}],[\"arc<mutex<file>>\",{\"1\":{\"25\":1}}],[\"arc<mutex<bufwriter<file>>>\",{\"1\":{\"24\":1}}],[\"arc<mutex<vec<compactionfilter>>>\",{\"1\":{\"21\":1}}],[\"arc<memtable>\",{\"1\":{\"21\":1}}],[\"arc<blockcache>\",{\"1\":{\"21\":1}}],[\"arc<rwlock<arc<lsmstoragestate>>>\",{\"1\":{\"21\":1}}],[\"auto在一些场景下使用可能会导致潜在的风险\",{\"1\":{\"41\":1}}],[\"auto的使用还可能避免可能的额外的内存复制开销\",{\"1\":{\"40\":1}}],[\"auto的型别推导与模板推导规则基本一致\",{\"1\":{\"35\":1}}],[\"auto甚至能表示一些只有编译器才知道的类型\",{\"1\":{\"40\":1}}],[\"auto可以简化变量声明\",{\"1\":{\"40\":1}}],[\"auto类型推导\",{\"1\":{\"37\":1}}],[\"auto\",{\"0\":{\"39\":1},\"1\":{\"35\":3,\"36\":9,\"37\":8,\"40\":6,\"41\":1,\"43\":1,\"46\":3,\"49\":1,\"55\":3,\"56\":1,\"57\":3,\"63\":3,\"66\":3,\"68\":2,\"69\":2,\"72\":1,\"74\":1,\"75\":2,\"76\":1,\"77\":1}}],[\"add\",{\"1\":{\"25\":1,\"45\":2}}],[\"approximate\",{\"1\":{\"22\":1}}],[\"ahead\",{\"1\":{\"17\":1,\"24\":1}}],[\"and\",{\"1\":{\"5\":1}}],[\"总体架构\",{\"0\":{\"17\":1}}],[\"is\",{\"1\":{\"61\":2}}],[\"islucky\",{\"1\":{\"47\":7}}],[\"iterator\",{\"1\":{\"40\":1}}],[\"it\",{\"1\":{\"40\":2,\"49\":2}}],[\"it>\",{\"1\":{\"40\":1}}],[\"if\",{\"1\":{\"37\":2,\"47\":3,\"63\":3}}],[\"i\",{\"1\":{\"37\":2}}],[\"impl已经是一个完整类型即可\",{\"1\":{\"77\":1}}],[\"impl>的代码之前\",{\"1\":{\"77\":1}}],[\"impl类型的定义\",{\"1\":{\"77\":1}}],[\"implementation\",{\"1\":{\"77\":2}}],[\"impl\",{\"1\":{\"22\":2,\"24\":2,\"25\":2,\"77\":13}}],[\"imm\",{\"1\":{\"21\":1}}],[\"immutable中检索\",{\"1\":{\"19\":1}}],[\"immutable\",{\"1\":{\"17\":1}}],[\"include\",{\"1\":{\"77\":14}}],[\"investment\",{\"1\":{\"63\":8}}],[\"insert\",{\"1\":{\"49\":1}}],[\"index\",{\"1\":{\"37\":1}}],[\"initlist的类型为\",{\"1\":{\"36\":1}}],[\"initlist\",{\"1\":{\"36\":1}}],[\"initializer\",{\"1\":{\"36\":5,\"43\":2,\"75\":2}}],[\"int>的隐式转换导致的复制\",{\"1\":{\"40\":1}}],[\"int>到std\",{\"1\":{\"40\":1}}],[\"int>\",{\"1\":{\"40\":3}}],[\"int的x的指针\",{\"1\":{\"30\":1}}],[\"int的x的引用\",{\"1\":{\"30\":1}}],[\"int\",{\"1\":{\"30\":17,\"32\":3,\"33\":4,\"36\":4,\"37\":9,\"43\":7,\"44\":3,\"45\":2,\"47\":1,\"52\":4,\"55\":2,\"56\":3,\"61\":3,\"67\":2,\"71\":2}}],[\"introduction\",{\"0\":{\"6\":1}}],[\"inner\",{\"1\":{\"21\":1}}],[\"idx\",{\"1\":{\"23\":2}}],[\"id\",{\"1\":{\"21\":1,\"22\":3,\"23\":3,\"25\":3}}],[\"id对应的sstable对象\",{\"1\":{\"21\":1}}],[\"id列表\",{\"1\":{\"21\":1}}],[\"io\",{\"1\":{\"16\":1}}],[\"教程文档\",{\"1\":{\"16\":1}}],[\"项目链接\",{\"1\":{\"16\":1}}],[\"迟sir的教学性质的lsm+rust项目\",{\"1\":{\"16\":1}}],[\"背景\",{\"0\":{\"16\":1}}],[\"一旦最后一个std\",{\"1\":{\"76\":1}}],[\"一样的问题\",{\"1\":{\"55\":1}}],[\"一般来说调用f\",{\"1\":{\"44\":1}}],[\"一\",{\"1\":{\"15\":1,\"27\":1}}],[\"而在使用delete之前会通过static\",{\"1\":{\"77\":1}}],[\"而这些数据成员的访问将通过指针间接访问\",{\"1\":{\"77\":1}}],[\"而用小括号创建对象将调用后者构造函数\",{\"1\":{\"75\":1}}],[\"而使用make\",{\"1\":{\"72\":1}}],[\"而是std\",{\"1\":{\"68\":1}}],[\"而shared\",{\"1\":{\"66\":1,\"77\":1}}],[\"而如果使用make函数\",{\"1\":{\"71\":1}}],[\"而如果使用using则会简化很多\",{\"1\":{\"45\":1}}],[\"而如果sp1和sp2之间使用赋值操作\",{\"1\":{\"65\":1}}],[\"而剩下的还在远处\",{\"1\":{\"52\":1}}],[\"而c++11中并没有要求此时f的调用栈是可解开的\",{\"1\":{\"52\":1}}],[\"而null只能转换成普通指针\",{\"1\":{\"44\":1}}],[\"而nullptr的类型是std\",{\"1\":{\"44\":1}}],[\"而不是std\",{\"1\":{\"77\":1}}],[\"而不是\",{\"0\":{\"47\":1}}],[\"而不是f\",{\"1\":{\"44\":1}}],[\"而不是0和\",{\"0\":{\"44\":1}}],[\"而不是auto类型推导\",{\"1\":{\"36\":1}}],[\"而highpriority也是指向该临时对象的引用\",{\"1\":{\"41\":1}}],[\"而非直接使用\",{\"0\":{\"69\":1}}],[\"而非\",{\"0\":{\"49\":1}}],[\"而非显式声明\",{\"0\":{\"40\":1}}],[\"而非万能引用\",{\"0\":{\"30\":1}}],[\"而且c++14的lambda函数也允许在形参声明中使用auto\",{\"1\":{\"36\":1}}],[\"而block是由若干key\",{\"1\":{\"23\":1}}],[\"而immutable则可以有多个\",{\"1\":{\"22\":1}}],[\"而观察节点在收到提议节点发送的区块之后会根据algo2对区块的交易进行验证\",{\"1\":{\"13\":1}}],[\"而交易tx5​因不满足ssi而退出\",{\"1\":{\"13\":1}}],[\"并将放在主类\",{\"1\":{\"77\":1}}],[\"并将其存储在\",{\"1\":{\"67\":1}}],[\"并且让这些使用者依赖于这些头文件\",{\"1\":{\"77\":1}}],[\"并且如果继承的基类函数的析构函数为虚函数\",{\"1\":{\"61\":1}}],[\"并且会保存交易的相关信息\",{\"1\":{\"13\":1}}],[\"并返回constexpr类型结果的编译时函数\",{\"1\":{\"57\":1}}],[\"并执行func的异常处理代码\",{\"1\":{\"51\":1}}],[\"并未做优化所以这里也略过\",{\"1\":{\"13\":1}}],[\"并生成新的区块\",{\"1\":{\"13\":1}}],[\"窗口外区块\",{\"1\":{\"13\":1}}],[\"将std\",{\"1\":{\"63\":1}}],[\"将meta\",{\"1\":{\"23\":1}}],[\"将blockmeta数组序列化成字节数组\",{\"1\":{\"23\":1}}],[\"将整个block对象序列化为字节数组\",{\"1\":{\"23\":1}}],[\"将immutable转换为sstable文件\",{\"1\":{\"22\":1}}],[\"将wal落盘\",{\"1\":{\"22\":1}}],[\"将key\",{\"1\":{\"18\":1}}],[\"将修改保存至key\",{\"1\":{\"18\":1}}],[\"将写集中每一项对应的πwrite​合并至tw​以及根据映射集合删除失效路径\",{\"1\":{\"13\":1}}],[\"将事务的执行结果提交到底层账本中去\",{\"1\":{\"11\":1}}],[\"28\",{\"1\":{\"57\":1}}],[\"20\",{\"1\":{\"43\":2,\"75\":2}}],[\"27\",{\"1\":{\"30\":2,\"36\":9,\"57\":1}}],[\"2b\",{\"1\":{\"23\":2,\"24\":2}}],[\"2\",{\"1\":{\"23\":2,\"36\":5,\"43\":1,\"57\":2,\"67\":2}}],[\"23\",{\"1\":{\"13\":1,\"36\":3}}],[\"21\",{\"0\":{\"5\":1}}],[\"滑动窗口\",{\"1\":{\"13\":1}}],[\"更新相应的映射集合mi↦r\",{\"1\":{\"13\":1}}],[\"还没有计算新的根节点的值\",{\"1\":{\"13\":1}}],[\"还会交易的写集\",{\"1\":{\"12\":1}}],[\"树插入到tw​中\",{\"1\":{\"13\":1}}],[\"对象的内存被释放\",{\"1\":{\"76\":1}}],[\"对象占用的内存才真正被释放\",{\"1\":{\"76\":1}}],[\"对象被销毁\",{\"1\":{\"76\":1}}],[\"对象被删除\",{\"1\":{\"63\":1}}],[\"对象分配和控制块内存分配\",{\"1\":{\"72\":1}}],[\"对象使用给定实参创建\",{\"1\":{\"63\":1}}],[\"对此解决的办法与前面类似\",{\"1\":{\"77\":1}}],[\"对此如果使用throw\",{\"1\":{\"52\":1}}],[\"对此c++11引入了统一的初始化形式\",{\"1\":{\"43\":1}}],[\"对于使用make系列函数创建方法\",{\"1\":{\"75\":1}}],[\"对于共享资源使用\",{\"0\":{\"64\":1}}],[\"对于独占资源使用\",{\"0\":{\"63\":1}}],[\"对于push\",{\"1\":{\"52\":1}}],[\"对于一些不会产生异常的函数来说\",{\"1\":{\"52\":1}}],[\"对于大括号初始化表达式的处理方式\",{\"1\":{\"36\":1}}],[\"对于函数形式为\",{\"1\":{\"33\":1}}],[\"对交易的可序列化检查算法如上所示\",{\"1\":{\"13\":1}}],[\"对应的写验证πwrite​\",{\"1\":{\"13\":1}}],[\"对读写集进行签名\",{\"1\":{\"12\":1}}],[\"7\",{\"1\":{\"13\":1,\"57\":1}}],[\"签名验证是否通过\",{\"1\":{\"13\":1}}],[\"检查是否在窗口内\",{\"1\":{\"13\":1}}],[\"提议节点会将生成的区块同步给观察节点和存储节点\",{\"1\":{\"13\":1}}],[\"提议节点收到来自存储节点的交易后会按照顺序依次对事务做以下验证\",{\"1\":{\"13\":1}}],[\"提议节点通过共识协议保证交易接受顺序的一致性\",{\"1\":{\"13\":1}}],[\"同一类型不同的析构函数的shared\",{\"1\":{\"66\":1}}],[\"同一交易发送到共识节点时其区块的高度要大于其在存储节点执行时区块的高度\",{\"1\":{\"13\":1}}],[\"同样如果该类中声明了移动构造函数\",{\"1\":{\"61\":1}}],[\"同时b还保存有a的所有权\",{\"1\":{\"68\":1}}],[\"同时在对象不被任何其他对象所有的时候进行析构\",{\"1\":{\"64\":1}}],[\"同时也支持自定义析构函数\",{\"1\":{\"63\":1}}],[\"同时也会带来额外的内存空间消耗\",{\"1\":{\"40\":1}}],[\"同时实现raii特性\",{\"1\":{\"63\":1}}],[\"同时标准库会调用std\",{\"1\":{\"52\":1}}],[\"同时考虑到二者高度差值越大可能出现冲突的概率就越大\",{\"1\":{\"13\":1}}],[\"同上述代码效果一致\",{\"1\":{\"77\":1}}],[\"同上\",{\"1\":{\"36\":2,\"68\":1}}],[\"同之前一样\",{\"1\":{\"30\":1,\"45\":1,\"61\":1}}],[\"其析构函数被调用\",{\"1\":{\"77\":1}}],[\"其在创建指向\",{\"1\":{\"67\":1}}],[\"其他数据\",{\"1\":{\"65\":1}}],[\"其他函数同之前一样\",{\"1\":{\"61\":1}}],[\"其实现的是对象专属所有权语义\",{\"1\":{\"63\":1}}],[\"其可以在成员参数列表之后来指定this对象的左值与右值属性\",{\"1\":{\"48\":1}}],[\"其引用的是该元素所在的字对象\",{\"1\":{\"41\":1}}],[\"其结构体定义\",{\"1\":{\"23\":1}}],[\"其中定义了一个函数std\",{\"1\":{\"67\":1}}],[\"其中控制块中包含的内容有\",{\"1\":{\"65\":1}}],[\"其中slice保存的是序列化后的json对象\",{\"1\":{\"25\":1}}],[\"其中data\",{\"1\":{\"23\":1}}],[\"其中block\",{\"1\":{\"23\":1}}],[\"其中删除操作实际上就是value为空的修改操作\",{\"1\":{\"18\":1}}],[\"其高度为i的区块的根节点分别记为hsi​和hci​\",{\"1\":{\"13\":1}}],[\"其主要特点包括\",{\"1\":{\"6\":1}}],[\"完全状态保存在存储节点中\",{\"1\":{\"13\":1}}],[\"完全状态的子集\",{\"1\":{\"13\":1}}],[\"写操作包括修改和删除操作\",{\"1\":{\"18\":1}}],[\"写操作主要包括以下四步\",{\"1\":{\"18\":1}}],[\"写流程\",{\"0\":{\"18\":1}}],[\"写过记录k的区块集合\",{\"1\":{\"13\":1}}],[\"写集\",{\"1\":{\"13\":1}}],[\"读操作主要包括以下两步\",{\"1\":{\"19\":1}}],[\"读流程\",{\"0\":{\"19\":1}}],[\"读写集等\",{\"1\":{\"13\":1}}],[\"读\",{\"1\":{\"13\":1}}],[\"读书笔记\",{\"0\":{\"3\":1}}],[\"keybytes\",{\"1\":{\"23\":4}}],[\"keyslice\",{\"1\":{\"22\":2,\"23\":1,\"24\":1}}],[\"key\",{\"1\":{\"17\":3,\"22\":2,\"23\":9,\"24\":4}}],[\"k\",{\"1\":{\"13\":3}}],[\"move\",{\"1\":{\"61\":3,\"77\":2}}],[\"modern\",{\"0\":{\"26\":1},\"1\":{\"27\":1,\"39\":1,\"42\":1,\"62\":1}}],[\"myalloc<t>>\",{\"1\":{\"45\":3}}],[\"myalloclist<t>\",{\"1\":{\"45\":2}}],[\"myalloclist<t>对象\",{\"1\":{\"45\":1}}],[\"myalloclist<t>是\",{\"1\":{\"45\":1}}],[\"myalloclist\",{\"1\":{\"45\":2}}],[\"mywidget2的类型是const\",{\"1\":{\"37\":1}}],[\"mywidget2\",{\"1\":{\"37\":1}}],[\"mywidget1的类型为widget\",{\"1\":{\"37\":1}}],[\"mywidget1\",{\"1\":{\"37\":1}}],[\"m\",{\"1\":{\"40\":2}}],[\"main\",{\"1\":{\"61\":3,\"67\":2}}],[\"makeinvestment\",{\"1\":{\"63\":4}}],[\"makelogentry\",{\"1\":{\"61\":2,\"63\":1,\"66\":1}}],[\"make\",{\"1\":{\"48\":1,\"65\":1,\"68\":1,\"69\":5,\"71\":1,\"72\":1,\"75\":2,\"76\":2,\"77\":4}}],[\"max\",{\"1\":{\"23\":2}}],[\"map<int\",{\"1\":{\"61\":2}}],[\"map<std\",{\"1\":{\"40\":1,\"45\":2}}],[\"map\",{\"1\":{\"22\":1}}],[\"manifest的存储格式如下\",{\"1\":{\"25\":1}}],[\"manifest的结构体\",{\"1\":{\"25\":1}}],[\"manifestrecord\",{\"1\":{\"25\":2}}],[\"manifest保存的内存数据类型\",{\"1\":{\"25\":1}}],[\"manifest文件\",{\"1\":{\"25\":1}}],[\"manifest记录lsm在内存中的数据\",{\"1\":{\"25\":1}}],[\"manifest\",{\"0\":{\"25\":1},\"1\":{\"21\":1,\"25\":2}}],[\"manifest相关方法\",{\"1\":{\"25\":1}}],[\"manifest相关\",{\"1\":{\"21\":1}}],[\"mutexguard<\",{\"1\":{\"25\":1}}],[\"mutex<option<std\",{\"1\":{\"21\":2}}],[\"mutex<\",{\"1\":{\"21\":1}}],[\"mut\",{\"1\":{\"22\":1,\"23\":2}}],[\"mutable在任意时刻只能有一个\",{\"1\":{\"22\":1}}],[\"mvcc\",{\"1\":{\"21\":1}}],[\"mvcc相关\",{\"1\":{\"21\":1}}],[\"metadata\",{\"1\":{\"23\":1}}],[\"meta\",{\"1\":{\"23\":10}}],[\"mem\",{\"1\":{\"18\":1}}],[\"memtableiterator\",{\"1\":{\"22\":1}}],[\"memtable提供了以下方法\",{\"1\":{\"22\":1}}],[\"memtable分为两种\",{\"1\":{\"22\":1}}],[\"memtable是lsm的在内存中的组件\",{\"1\":{\"22\":1}}],[\"memtables\",{\"1\":{\"21\":1}}],[\"memtable\",{\"0\":{\"22\":1},\"1\":{\"17\":2,\"21\":2,\"22\":1,\"25\":1}}],[\"merkle\",{\"1\":{\"9\":1}}],[\"mid\",{\"1\":{\"57\":3}}],[\"midpoint\",{\"1\":{\"57\":3}}],[\"mini\",{\"1\":{\"16\":2}}],[\"minilsm\",{\"1\":{\"21\":1}}],[\"minilsm为顶层封装结构体\",{\"1\":{\"21\":1}}],[\"minilsm基本组件\",{\"0\":{\"20\":1}}],[\"minilsm概览\",{\"0\":{\"15\":1}}],[\"minilsm源码阅读笔记\",{\"1\":{\"15\":1,\"20\":1}}],[\"minilsm源码阅读\",{\"0\":{\"14\":1}}],[\"mi↦r\",{\"1\":{\"13\":1}}],[\"mr\",{\"1\":{\"13\":1}}],[\"算法中一些符号的含义\",{\"1\":{\"13\":1}}],[\"πwrite​>打包并广播给所有的共识节点\",{\"1\":{\"12\":1}}],[\"πtee​\",{\"1\":{\"12\":1}}],[\"πcons​\",{\"1\":{\"9\":1}}],[\"rc变为0\",{\"1\":{\"68\":1}}],[\"rc仍为1\",{\"1\":{\"68\":1}}],[\"rc\",{\"1\":{\"68\":1}}],[\"rule\",{\"1\":{\"61\":1}}],[\"rhs\",{\"1\":{\"60\":2,\"77\":6}}],[\"rx=cx\",{\"1\":{\"32\":1}}],[\"rx=x\",{\"1\":{\"30\":1}}],[\"rx\",{\"1\":{\"30\":3,\"32\":1}}],[\"rx是指向作为const\",{\"1\":{\"30\":1}}],[\"reallybigtype对象的内存就会被释放\",{\"1\":{\"76\":1}}],[\"reallybigtype\",{\"1\":{\"76\":3}}],[\"realestate\",{\"1\":{\"63\":2}}],[\"read\",{\"1\":{\"23\":1}}],[\"ref\",{\"1\":{\"68\":1}}],[\"reflectedmid的值\",{\"1\":{\"57\":1}}],[\"reflectedmid\",{\"1\":{\"57\":1}}],[\"reflection\",{\"1\":{\"57\":2}}],[\"reference<t>\",{\"1\":{\"45\":2}}],[\"reference比较特殊\",{\"1\":{\"41\":1}}],[\"reference相对于其他的std\",{\"1\":{\"41\":1}}],[\"reference\",{\"1\":{\"41\":1,\"45\":2}}],[\"rettype\",{\"1\":{\"52\":3}}],[\"return\",{\"1\":{\"36\":1,\"37\":4,\"40\":3,\"57\":4,\"61\":3,\"63\":1,\"67\":2,\"69\":1}}],[\"red限制在color域内\",{\"1\":{\"46\":1}}],[\"red在color所在的作用域\",{\"1\":{\"46\":1}}],[\"red\",{\"1\":{\"46\":2}}],[\"remove\",{\"1\":{\"45\":4}}],[\"reset\",{\"1\":{\"63\":3}}],[\"resetv\",{\"1\":{\"36\":2}}],[\"result\",{\"1\":{\"57\":4}}],[\"results\",{\"1\":{\"56\":1}}],[\"result<arc<block>>\",{\"1\":{\"23\":1}}],[\"result<\",{\"1\":{\"22\":3,\"23\":1,\"24\":1,\"25\":2}}],[\"result<self>\",{\"1\":{\"22\":2,\"23\":1,\"24\":2,\"25\":1}}],[\"record\",{\"1\":{\"24\":1,\"25\":3}}],[\"recover\",{\"1\":{\"22\":1,\"24\":1,\"25\":1}}],[\"range\",{\"1\":{\"17\":1}}],[\"r\",{\"1\":{\"12\":1}}],[\"root​\",{\"1\":{\"9\":2,\"13\":1}}],[\"左边是当前新创建的链下状态\",{\"1\":{\"12\":1}}],[\"wpw现在悬空\",{\"1\":{\"68\":1}}],[\"wpw指向与spw所指相同的widget\",{\"1\":{\"68\":1}}],[\"wpw\",{\"1\":{\"68\":4}}],[\"weak\",{\"1\":{\"65\":1,\"68\":5,\"76\":7}}],[\"white早已在这个作用中声明\",{\"1\":{\"46\":1}}],[\"white\",{\"1\":{\"46\":10}}],[\"while\",{\"1\":{\"40\":1,\"56\":1}}],[\"w3\",{\"1\":{\"43\":1}}],[\"w2\",{\"1\":{\"43\":1,\"77\":2}}],[\"w1\",{\"1\":{\"43\":1,\"77\":3}}],[\"widgetdeleter\",{\"1\":{\"74\":4}}],[\"widget在堆上创建了widget对象\",{\"1\":{\"71\":2}}],[\"widget被销毁\",{\"1\":{\"68\":1}}],[\"widget<t>含有一个\",{\"1\":{\"45\":1}}],[\"widget\",{\"1\":{\"37\":7,\"41\":4,\"43\":4,\"45\":2,\"52\":1,\"60\":5,\"66\":8,\"69\":2,\"71\":1,\"72\":1,\"74\":3,\"77\":64}}],[\"with\",{\"1\":{\"22\":1,\"32\":1}}],[\"write\",{\"1\":{\"17\":1,\"24\":1}}],[\"wal相关方法\",{\"1\":{\"24\":1}}],[\"wal的结构体\",{\"1\":{\"24\":1}}],[\"wal的日志持久化格式为\",{\"1\":{\"24\":1}}],[\"wal对象\",{\"1\":{\"22\":1}}],[\"wal\",{\"0\":{\"24\":1},\"1\":{\"17\":1,\"21\":1,\"22\":4,\"24\":3}}],[\"w↦i​\",{\"1\":{\"13\":2}}],[\"w​和mr\",{\"1\":{\"13\":1}}],[\"w​\",{\"1\":{\"13\":1}}],[\"w\",{\"1\":{\"12\":2,\"13\":1,\"37\":8,\"41\":9,\"52\":2,\"77\":1}}],[\"离开了tee之后\",{\"1\":{\"12\":1}}],[\"404\",{\"1\":{\"78\":1}}],[\"42\",{\"1\":{\"37\":2}}],[\"4b\",{\"1\":{\"24\":1,\"25\":1}}],[\"4\",{\"1\":{\"12\":1,\"57\":1}}],[\"lvalue\",{\"1\":{\"45\":2}}],[\"literal\",{\"1\":{\"56\":1}}],[\"list类型的参数构造\",{\"1\":{\"75\":1}}],[\"list类型作为参数和非作std\",{\"1\":{\"75\":1}}],[\"list\",{\"1\":{\"43\":2,\"45\":2}}],[\"list<t\",{\"1\":{\"45\":3}}],[\"list<t>\",{\"1\":{\"36\":1}}],[\"list<t>中的t\",{\"1\":{\"36\":1}}],[\"list<int>\",{\"1\":{\"36\":3}}],[\"limit\",{\"1\":{\"21\":1}}],[\"last\",{\"1\":{\"23\":2}}],[\"lower\",{\"1\":{\"22\":1}}],[\"lock\",{\"1\":{\"21\":1,\"25\":1,\"68\":2}}],[\"loggingdel\",{\"1\":{\"66\":4}}],[\"log\",{\"1\":{\"17\":1,\"24\":1}}],[\"level0层所有的sstable\",{\"1\":{\"25\":1}}],[\"levels\",{\"1\":{\"21\":1}}],[\"len\",{\"1\":{\"23\":4,\"24\":4,\"25\":2}}],[\"ledger\",{\"1\":{\"8\":1}}],[\"l0\",{\"1\":{\"21\":1}}],[\"lsm在磁盘中是典型的分层结构\",{\"1\":{\"23\":1}}],[\"lsm选项\",{\"1\":{\"21\":1}}],[\"lsm全局锁\",{\"1\":{\"21\":1}}],[\"lsm状态\",{\"1\":{\"21\":1}}],[\"lsmstorageinner\",{\"1\":{\"21\":1}}],[\"lsmstorageinner包含存储状态以及lsm的配置信息\",{\"1\":{\"21\":1}}],[\"lsmstoragestate\",{\"1\":{\"21\":1}}],[\"lsmstoragestate维护存储的核心组件状态\",{\"1\":{\"21\":1}}],[\"lsmstorageoptions\",{\"1\":{\"21\":1}}],[\"lsmstorageoptions主要保存lsm相关的配置信息\",{\"1\":{\"21\":1}}],[\"lsm存储引擎一般包括三个部分\",{\"1\":{\"17\":1}}],[\"lsm\",{\"0\":{\"21\":1},\"1\":{\"16\":2,\"21\":1}}],[\"l9\",{\"1\":{\"13\":1}}],[\"l8\",{\"1\":{\"13\":1}}],[\"l4\",{\"1\":{\"13\":1}}],[\"l5\",{\"1\":{\"12\":1}}],[\"l3\",{\"1\":{\"12\":1}}],[\"l2\",{\"1\":{\"12\":1}}],[\"l14\",{\"1\":{\"13\":1}}],[\"l13\",{\"1\":{\"13\":1}}],[\"l1\",{\"1\":{\"12\":1}}],[\"验证从hold​中读取结果的正确性\",{\"1\":{\"12\":1}}],[\"验证客户端发送的交易签名\",{\"1\":{\"12\":1}}],[\"验证新区块\",{\"1\":{\"8\":1}}],[\"else\",{\"1\":{\"63\":2}}],[\"elements\",{\"1\":{\"23\":1}}],[\"error\",{\"1\":{\"61\":2}}],[\"e\",{\"1\":{\"40\":2}}],[\"effective\",{\"0\":{\"26\":1},\"1\":{\"27\":1,\"39\":1,\"42\":1,\"62\":1}}],[\"expired\",{\"1\":{\"68\":1}}],[\"exp\",{\"1\":{\"56\":1}}],[\"expr\",{\"1\":{\"29\":1}}],[\"exception\",{\"1\":{\"53\":1}}],[\"extra部分则保存了block中key\",{\"1\":{\"23\":1}}],[\"extra部分保存的是meta\",{\"1\":{\"23\":1}}],[\"extra\",{\"1\":{\"23\":2}}],[\"exection\",{\"1\":{\"12\":1}}],[\"endl\",{\"1\":{\"61\":1,\"67\":2}}],[\"enum\",{\"1\":{\"25\":1,\"46\":2}}],[\"encode\",{\"1\":{\"23\":2}}],[\"entry\",{\"1\":{\"23\":4}}],[\"enable\",{\"1\":{\"21\":1,\"67\":2}}],[\"environment\",{\"1\":{\"12\":1}}],[\"生成机制\",{\"0\":{\"61\":1}}],[\"生成的特种函数都是具有public访问层级且是inline\",{\"1\":{\"60\":1}}],[\"生成带有边界的iterator\",{\"1\":{\"22\":1}}],[\"生成区块并更新区块链的状态\",{\"1\":{\"11\":1}}],[\"生成新区块\",{\"1\":{\"8\":1}}],[\"交易tx1​−tx4​都可以正常提交\",{\"1\":{\"13\":1}}],[\"交易获取读集rtx​和写集wtx​\",{\"1\":{\"11\":1}}],[\"交易处理\",{\"0\":{\"10\":1}}],[\"σtx​>\",{\"1\":{\"11\":1}}],[\"流程概述\",{\"0\":{\"11\":1}}],[\"持久化的日志文件\",{\"1\":{\"24\":1}}],[\"持久化保存的账本\",{\"1\":{\"9\":1}}],[\"持久化存储账本和其他区块相关的数据\",{\"1\":{\"8\":1}}],[\"链下部分\",{\"1\":{\"9\":1}}],[\"链上部分\",{\"1\":{\"9\":1}}],[\"单个交易tx的哈希值\",{\"1\":{\"9\":1}}],[\"h\",{\"1\":{\"77\":15}}],[\"highpriority\",{\"1\":{\"41\":4}}],[\"hashmap<usize\",{\"1\":{\"21\":1}}],[\"https\",{\"1\":{\"16\":2}}],[\"htx​\",{\"1\":{\"9\":1}}],[\"htx\",{\"1\":{\"9\":1}}],[\"hold​\",{\"1\":{\"12\":1}}],[\"hold​指的是h99​\",{\"1\":{\"12\":1}}],[\"hstate\",{\"1\":{\"9\":1}}],[\"hprev\",{\"1\":{\"9\":1}}],[\"共识相关的参数\",{\"1\":{\"9\":1}}],[\"共识节点交易提交流程\",{\"0\":{\"13\":1}}],[\"共识节点验证执行结果后\",{\"1\":{\"11\":1}}],[\"共识节点\",{\"1\":{\"8\":1}}],[\"vpw\",{\"1\":{\"66\":1}}],[\"vw\",{\"1\":{\"52\":2}}],[\"virtual\",{\"1\":{\"48\":3,\"63\":1}}],[\"view\",{\"1\":{\"8\":1}}],[\"v2\",{\"1\":{\"43\":1}}],[\"v1\",{\"1\":{\"43\":1}}],[\"v初始内容为1\",{\"1\":{\"43\":1}}],[\"v\",{\"1\":{\"36\":3,\"37\":4,\"43\":1}}],[\"vector和gadget\",{\"1\":{\"77\":1}}],[\"vector对象的unique\",{\"1\":{\"75\":1}}],[\"vector<double>\",{\"1\":{\"77\":4}}],[\"vector<std\",{\"1\":{\"66\":1}}],[\"vector<widget>\",{\"1\":{\"52\":1}}],[\"vector<t>\",{\"1\":{\"41\":1}}],[\"vector<bool>对象中第五个bit所在字的引用\",{\"1\":{\"41\":1}}],[\"vector<bool>\",{\"1\":{\"41\":4}}],[\"vector<int>>\",{\"1\":{\"75\":2}}],[\"vector<int>\",{\"1\":{\"36\":1,\"37\":3,\"40\":1,\"43\":3,\"49\":1}}],[\"vector\",{\"1\":{\"37\":1,\"43\":2}}],[\"vector的简化版本\",{\"1\":{\"37\":1}}],[\"vec<manifestrecord>\",{\"1\":{\"25\":1}}],[\"vec<blockmeta>\",{\"1\":{\"23\":2}}],[\"vec<u16>\",{\"1\":{\"23\":1}}],[\"vec<u8>\",{\"1\":{\"23\":2}}],[\"vec<usize>\",{\"1\":{\"21\":2,\"25\":1}}],[\"vec<\",{\"1\":{\"21\":1}}],[\"vec<arc<memtable>>\",{\"1\":{\"21\":1}}],[\"var\",{\"1\":{\"35\":3,\"43\":2}}],[\"values\",{\"1\":{\"49\":4,\"61\":2}}],[\"value的索引\",{\"1\":{\"23\":1}}],[\"value的偏移值\",{\"1\":{\"23\":1}}],[\"value键值对的结构\",{\"1\":{\"23\":1}}],[\"value键值对\",{\"1\":{\"23\":1}}],[\"value写入memtable\",{\"1\":{\"18\":1}}],[\"value\",{\"1\":{\"17\":1,\"22\":1,\"23\":3,\"24\":4,\"40\":1}}],[\"value对的个数\",{\"1\":{\"23\":1}}],[\"value对及其索引组成\",{\"1\":{\"23\":1}}],[\"value对保存至磁盘中的wal中\",{\"1\":{\"18\":1}}],[\"value对结构\",{\"1\":{\"17\":1}}],[\"value对文件\",{\"1\":{\"17\":1}}],[\"volatile属性\",{\"1\":{\"30\":2,\"32\":2}}],[\"void>\",{\"1\":{\"47\":1}}],[\"void\",{\"1\":{\"29\":1,\"30\":3,\"31\":1,\"32\":2,\"33\":3,\"36\":2,\"40\":1,\"44\":6,\"45\":2,\"47\":8,\"48\":6,\"52\":2,\"57\":2,\"71\":1}}],[\"vldb\",{\"0\":{\"5\":1}}],[\"部分元素已被移出\",{\"1\":{\"52\":1}}],[\"部分\",{\"1\":{\"8\":2}}],[\"发起交易\",{\"1\":{\"8\":1}}],[\"cpp文件内\",{\"1\":{\"77\":1}}],[\"cpp\",{\"1\":{\"77\":6}}],[\"c的数据结构\",{\"1\":{\"68\":1}}],[\"customdeleter2\",{\"1\":{\"66\":2}}],[\"customdeleter1\",{\"1\":{\"66\":2}}],[\"currvalue的类型为std\",{\"1\":{\"40\":1}}],[\"currvalue\",{\"1\":{\"40\":1}}],[\"called\",{\"1\":{\"61\":2,\"67\":2}}],[\"cache或者sstable中读取对应的block\",{\"1\":{\"23\":1}}],[\"cache\",{\"1\":{\"21\":1,\"23\":2}}],[\"cend\",{\"1\":{\"49\":1}}],[\"cbegin\",{\"1\":{\"49\":1}}],[\"c\",{\"1\":{\"46\":3}}],[\"cw\",{\"1\":{\"37\":3}}],[\"class\",{\"1\":{\"37\":1,\"43\":1,\"45\":2,\"46\":1,\"48\":2,\"52\":1,\"57\":1,\"60\":1,\"61\":5,\"63\":5,\"67\":1,\"76\":2,\"77\":9}}],[\"client\",{\"1\":{\"8\":1}}],[\"cx\",{\"1\":{\"30\":3,\"32\":1}}],[\"cx是const\",{\"1\":{\"30\":1}}],[\"cx=x\",{\"1\":{\"30\":1,\"32\":1}}],[\"c++中的特种函数主要包括\",{\"1\":{\"60\":1}}],[\"c++中一些特殊的特征类型\",{\"1\":{\"45\":1}}],[\"c++98风格\",{\"1\":{\"52\":1}}],[\"c++程序在执行过程中\",{\"1\":{\"51\":1}}],[\"c++异常处理流程\",{\"0\":{\"51\":1}}],[\"c++11风格\",{\"1\":{\"52\":1}}],[\"c++11\",{\"1\":{\"45\":3}}],[\"c++14返回值推导\",{\"1\":{\"63\":1}}],[\"c++14以后甚至可以修改constexpr的对象成员变量\",{\"1\":{\"57\":1}}],[\"c++14版本\",{\"1\":{\"40\":1}}],[\"c++14\",{\"1\":{\"36\":1,\"45\":3}}],[\"c++14允许auto用于函数返回值并会被推导\",{\"1\":{\"36\":1}}],[\"c++初始化的方式比较多样\",{\"1\":{\"43\":1}}],[\"c++\",{\"0\":{\"26\":1},\"1\":{\"27\":1,\"39\":1,\"42\":1,\"62\":1}}],[\"chunck\",{\"1\":{\"72\":1}}],[\"checksum\",{\"1\":{\"24\":1,\"25\":1}}],[\"char>\",{\"1\":{\"47\":1}}],[\"char\",{\"1\":{\"32\":3,\"33\":4,\"47\":4}}],[\"channel\",{\"1\":{\"21\":2}}],[\"chain\",{\"1\":{\"5\":1,\"8\":2}}],[\"chain协同的私有链\",{\"0\":{\"5\":1}}],[\"creating\",{\"1\":{\"61\":1}}],[\"createinitlist\",{\"1\":{\"36\":1}}],[\"create\",{\"1\":{\"22\":1,\"24\":1,\"25\":1}}],[\"crossbeam\",{\"1\":{\"21\":2}}],[\"crate\",{\"1\":{\"21\":10,\"22\":1,\"23\":6}}],[\"count\",{\"1\":{\"68\":1}}],[\"cout\",{\"1\":{\"61\":1,\"67\":2}}],[\"copy\",{\"1\":{\"61\":2}}],[\"color\",{\"1\":{\"46\":6}}],[\"control\",{\"1\":{\"65\":1}}],[\"controller\",{\"1\":{\"21\":1}}],[\"constexpr函数内也可以创建局部变量以及使用if\",{\"1\":{\"56\":1}}],[\"constexpr函数\",{\"1\":{\"56\":1}}],[\"constexpr\",{\"1\":{\"55\":2,\"56\":2,\"57\":10,\"61\":2}}],[\"constexpr变量\",{\"1\":{\"55\":1}}],[\"constexpr修饰的变量一定是编译时已知的\",{\"1\":{\"55\":1}}],[\"const放在成员函数参数列表之后来指定this对象的const属性\",{\"1\":{\"48\":1}}],[\"const<t>\",{\"1\":{\"45\":1}}],[\"const类型的实参\",{\"1\":{\"32\":1}}],[\"constint\",{\"1\":{\"30\":1}}],[\"const\",{\"1\":{\"30\":6,\"31\":2,\"32\":4,\"33\":1,\"36\":1,\"37\":4,\"40\":9,\"41\":2,\"45\":4,\"47\":2,\"55\":1,\"57\":6,\"61\":4}}],[\"consensus\",{\"1\":{\"8\":1}}],[\"computepriority\",{\"1\":{\"71\":3}}],[\"compactiontask\",{\"1\":{\"25\":1}}],[\"compaction任务等\",{\"1\":{\"25\":1}}],[\"compaction线程\",{\"1\":{\"21\":1}}],[\"compaction过滤器\",{\"1\":{\"21\":1}}],[\"compactioncontroller\",{\"1\":{\"21\":1}}],[\"compaction相关\",{\"1\":{\"21\":1}}],[\"compactionoptions\",{\"1\":{\"21\":1}}],[\"compaction\",{\"1\":{\"21\":5,\"25\":1}}],[\"compaction选项\",{\"1\":{\"21\":1}}],[\"com\",{\"1\":{\"16\":1}}],[\"客户端向其中之一的存储节点发送交易请求<txinput​\",{\"1\":{\"11\":1}}],[\"客户端\",{\"1\":{\"8\":1}}],[\"整体架构\",{\"0\":{\"8\":1}}],[\"充分的区块链安全保证机制\",{\"1\":{\"6\":1}}],[\"安全保证\",{\"1\":{\"6\":1}}],[\"利用分片提高区块链交易处理的扩展性\",{\"1\":{\"6\":1}}],[\"支持occ和ssi两种经典并发控制算法\",{\"1\":{\"13\":1}}],[\"支持高效分片\",{\"1\":{\"6\":1}}],[\"支持交易在不同节点并行执行\",{\"1\":{\"6\":1}}],[\"最终导致ab无法成功析构造成内存泄漏\",{\"1\":{\"68\":1}}],[\"最后一个std\",{\"1\":{\"76\":4}}],[\"最后std\",{\"1\":{\"63\":1}}],[\"最后存储节点会将交易txnsubmit​=<txinput​\",{\"1\":{\"12\":1}}],[\"最令人头疼的解析\",{\"1\":{\"43\":1}}],[\"最大的key\",{\"1\":{\"23\":1}}],[\"最大化系统吞吐量\",{\"1\":{\"6\":1}}],[\"最小的key\",{\"1\":{\"23\":1}}],[\"最小化区块节点的负担\",{\"1\":{\"6\":1}}],[\"会引入跨分片交易处理问题以及额外的安全问题\",{\"1\":{\"6\":1}}],[\"每个元素都是20的std\",{\"1\":{\"75\":1}}],[\"每个节点都需要保存完整的账本\",{\"1\":{\"6\":1}}],[\"每种类型不同\",{\"1\":{\"66\":1}}],[\"每种类型都包含一个json对象\",{\"1\":{\"25\":1}}],[\"每一次操作都会先被记录并持久化到wal中\",{\"1\":{\"24\":1}}],[\"每一层都是由若干sstable组成\",{\"1\":{\"23\":1}}],[\"每片内的节点仍然执行重复的计算和存储\",{\"1\":{\"6\":1}}],[\"治标不治本\",{\"1\":{\"6\":1}}],[\"网络变得更加中心化\",{\"1\":{\"6\":1}}],[\"扩展性有限\",{\"1\":{\"6\":1}}],[\"都需要执行所有的交易导致节点的存储压力和计算压力增加\",{\"1\":{\"6\":1}}],[\"pimpl指针指向的是一个不完整类型\",{\"1\":{\"77\":1}}],[\"pimpl的好处是将类的嵌套关系进行解耦\",{\"1\":{\"77\":1}}],[\"pimpl\",{\"1\":{\"77\":12}}],[\"pinv\",{\"1\":{\"63\":5}}],[\"pinvestment是std\",{\"1\":{\"63\":1}}],[\"pinvestment\",{\"1\":{\"63\":5}}],[\"pbigobj\",{\"1\":{\"76\":2}}],[\"pw2\",{\"1\":{\"66\":2}}],[\"pw1\",{\"1\":{\"66\":2}}],[\"pw\",{\"1\":{\"66\":5,\"74\":1}}],[\"pow\",{\"1\":{\"56\":2}}],[\"pow是绝不抛异常的\",{\"1\":{\"56\":1}}],[\"pointer\",{\"1\":{\"77\":1}}],[\"pointers\",{\"1\":{\"32\":1}}],[\"point的构造函数被声明为constexpr函数\",{\"1\":{\"57\":1}}],[\"point\",{\"1\":{\"37\":3,\"57\":11}}],[\"primary\",{\"1\":{\"77\":1}}],[\"priority\",{\"1\":{\"71\":1}}],[\"private\",{\"1\":{\"43\":1,\"45\":2,\"57\":1,\"61\":2,\"77\":7}}],[\"processpointer<const\",{\"1\":{\"47\":2}}],[\"processpointer<char>\",{\"1\":{\"47\":1}}],[\"processpointer<void>\",{\"1\":{\"47\":1}}],[\"processpointer\",{\"1\":{\"47\":1}}],[\"processwidget\",{\"1\":{\"41\":2,\"71\":3}}],[\"processing\",{\"1\":{\"5\":1}}],[\"proposers\",{\"1\":{\"8\":1}}],[\"p2\",{\"1\":{\"40\":6,\"57\":6}}],[\"p1\",{\"1\":{\"40\":6,\"57\":6}}],[\"p\",{\"1\":{\"33\":1,\"40\":1,\"52\":3,\"57\":3}}],[\"ptr删除器的类型不是该智能指针的一部分而是控制块的一部分\",{\"1\":{\"77\":1}}],[\"ptr删除器的类型是智能指针对象本身的一部分\",{\"1\":{\"77\":1}}],[\"ptr删除器类型不是\",{\"1\":{\"66\":1}}],[\"ptr删除器类型是\",{\"1\":{\"66\":1}}],[\"ptr则完全没有上述问题\",{\"1\":{\"77\":1}}],[\"ptr则不是\",{\"1\":{\"66\":1}}],[\"ptr换成std\",{\"1\":{\"77\":1}}],[\"ptr声明一个析构函数\",{\"1\":{\"77\":1}}],[\"ptr不需要析构函数\",{\"1\":{\"77\":1}}],[\"ptr不是一个独立的指针\",{\"1\":{\"68\":1}}],[\"ptr看起来天然适合做这种工作\",{\"1\":{\"77\":1}}],[\"ptr被销毁\",{\"1\":{\"76\":1}}],[\"ptr在pimpl指针上的表现上的区别的深层原因在于支持自定义删除器的方式不同\",{\"1\":{\"77\":1}}],[\"ptr在这里销毁\",{\"1\":{\"76\":2}}],[\"ptr在这销毁\",{\"1\":{\"76\":2}}],[\"ptr在多线程下可以保证引用计数的线程安全\",{\"1\":{\"65\":1}}],[\"ptrs还在\",{\"1\":{\"76\":2}}],[\"ptrs\",{\"1\":{\"76\":2}}],[\"ptrs和std\",{\"1\":{\"76\":2}}],[\"ptr和std\",{\"1\":{\"76\":1}}],[\"ptr和shared\",{\"1\":{\"75\":1,\"77\":1}}],[\"ptr接管\",{\"1\":{\"71\":1}}],[\"ptr保存对a的引用\",{\"1\":{\"68\":1}}],[\"ptr指针来判断是否悬空\",{\"1\":{\"68\":1}}],[\"ptr指向的类型\",{\"1\":{\"77\":1}}],[\"ptr指向控制块\",{\"1\":{\"76\":2}}],[\"ptr指向相同的位置\",{\"1\":{\"68\":1}}],[\"ptr指向与shared\",{\"1\":{\"68\":1}}],[\"ptr指向\",{\"1\":{\"67\":1}}],[\"ptr可以创建对应的shared\",{\"1\":{\"68\":1}}],[\"ptr可以转换成std\",{\"1\":{\"63\":1}}],[\"ptr可能悬空\",{\"1\":{\"68\":1}}],[\"ptr控制块的引用计数\",{\"1\":{\"68\":1}}],[\"ptr来创建\",{\"1\":{\"68\":1}}],[\"ptr一般通过shared\",{\"1\":{\"68\":1}}],[\"ptr前会检查是否已有\",{\"1\":{\"67\":1}}],[\"ptr也被视为是同一种类型\",{\"1\":{\"66\":1}}],[\"ptr的原始指针\",{\"1\":{\"77\":1}}],[\"ptr的循环引用问题\",{\"1\":{\"68\":1}}],[\"ptr的主要用途是解决shared\",{\"1\":{\"68\":1}}],[\"ptr的一种补充\",{\"1\":{\"68\":1}}],[\"ptr的析构函数是智能指针类型的一部分\",{\"1\":{\"66\":1}}],[\"ptr的存储结构为\",{\"1\":{\"65\":1}}],[\"ptr同样支持自定义析构函数\",{\"1\":{\"66\":1}}],[\"ptr类似\",{\"1\":{\"66\":1}}],[\"ptr会进行两次内存分配\",{\"1\":{\"72\":1}}],[\"ptr会被置空\",{\"1\":{\"65\":1}}],[\"ptr会创建控制块\",{\"1\":{\"65\":2}}],[\"ptr出发初始化std\",{\"1\":{\"65\":1}}],[\"ptr引用数\",{\"1\":{\"65\":1}}],[\"ptr对象及控制块\",{\"1\":{\"67\":1}}],[\"ptr对象\",{\"1\":{\"67\":1}}],[\"ptr对象本身大小为两个指针\",{\"1\":{\"65\":1}}],[\"ptr对象超出作用于后默认调用delete析构对象所指向的对象\",{\"1\":{\"63\":1}}],[\"ptr通过维护引用计算来实现复制和赋值操作\",{\"1\":{\"65\":1}}],[\"ptr实现的是对象共享所有权语义\",{\"1\":{\"64\":1}}],[\"ptr实现的工厂模式\",{\"1\":{\"63\":1}}],[\"ptr转为std\",{\"1\":{\"63\":1}}],[\"ptr是否悬空的方法为\",{\"1\":{\"68\":1}}],[\"ptr是对裸指针的简单封装\",{\"1\":{\"63\":1}}],[\"ptr是一个常量指针\",{\"1\":{\"32\":1}}],[\"ptr<impl>\",{\"1\":{\"77\":5}}],[\"ptr<investment\",{\"1\":{\"63\":1}}],[\"ptr<investment>类型\",{\"1\":{\"63\":1}}],[\"ptr<investment>\",{\"1\":{\"63\":2}}],[\"ptr<reallybigtype>\",{\"1\":{\"76\":1}}],[\"ptr<widget\",{\"1\":{\"74\":1,\"77\":1}}],[\"ptr<widget>构造函数必须被执行\",{\"1\":{\"71\":2}}],[\"ptr<widget>>\",{\"1\":{\"66\":1}}],[\"ptr<widget>\",{\"1\":{\"40\":6,\"66\":3,\"68\":2,\"69\":2,\"71\":2,\"72\":1,\"74\":1}}],[\"ptr<t>\",{\"1\":{\"69\":2}}],[\"ptr<type>\",{\"1\":{\"44\":1}}],[\"ptr<good>\",{\"1\":{\"67\":3}}],[\"ptr<bad>\",{\"1\":{\"67\":4}}],[\"ptr<base>\",{\"1\":{\"48\":1}}],[\"ptr<\",{\"1\":{\"66\":1}}],[\"ptr<std\",{\"1\":{\"45\":2}}],[\"ptr\",{\"0\":{\"76\":1},\"1\":{\"32\":2,\"40\":1,\"47\":1,\"63\":3,\"67\":3,\"68\":3,\"75\":1,\"77\":3}}],[\"px是指向作为const\",{\"1\":{\"30\":1}}],[\"px\",{\"1\":{\"30\":2}}],[\"pause\",{\"1\":{\"67\":1}}],[\"pair\",{\"1\":{\"52\":2}}],[\"pair的swap声明如下\",{\"1\":{\"52\":1}}],[\"pair<const\",{\"1\":{\"40\":2}}],[\"pair<std\",{\"1\":{\"40\":2}}],[\"params\",{\"1\":{\"52\":3,\"63\":5,\"69\":2}}],[\"param被推导为指向函数的引用\",{\"1\":{\"33\":1}}],[\"param被推导为指向函数的指针\",{\"1\":{\"33\":1}}],[\"param现在是指针\",{\"1\":{\"30\":1}}],[\"param现在是reference\",{\"1\":{\"30\":1,\"31\":1}}],[\"param的类型是const\",{\"1\":{\"30\":6}}],[\"param的类型是int\",{\"1\":{\"30\":2}}],[\"param是一个引用\",{\"1\":{\"30\":1}}],[\"param\",{\"1\":{\"29\":1,\"30\":3,\"31\":1,\"32\":2,\"33\":2,\"36\":1}}],[\"paramtype\",{\"1\":{\"29\":1}}],[\"parallel\",{\"1\":{\"5\":1}}],[\"path是wal的文件路径\",{\"1\":{\"22\":1}}],[\"pathbuf\",{\"1\":{\"21\":1}}],[\"path\",{\"1\":{\"21\":1,\"22\":2,\"24\":2,\"25\":2}}],[\"push\",{\"1\":{\"52\":1}}],[\"public\",{\"1\":{\"37\":1,\"48\":3,\"57\":1,\"60\":1,\"61\":5,\"63\":4,\"67\":2,\"77\":7}}],[\"pub\",{\"1\":{\"21\":24,\"22\":2,\"23\":12,\"24\":1,\"25\":2}}],[\"put\",{\"1\":{\"17\":1,\"22\":1,\"24\":1}}],[\"this对应的控制块\",{\"1\":{\"67\":1}}],[\"this对象的shared\",{\"1\":{\"67\":1}}],[\"this是一个模板基类\",{\"1\":{\"67\":1}}],[\"this<good>\",{\"1\":{\"67\":1}}],[\"this本身就已经被另一个shared\",{\"1\":{\"67\":1}}],[\"this\",{\"1\":{\"67\":5}}],[\"three\",{\"1\":{\"61\":1}}],[\"thread\",{\"1\":{\"21\":4}}],[\"throw\",{\"1\":{\"52\":2}}],[\"through\",{\"1\":{\"5\":1}}],[\"t2>\",{\"1\":{\"52\":1}}],[\"t1\",{\"1\":{\"52\":1}}],[\"test\",{\"1\":{\"77\":1}}],[\"template\",{\"1\":{\"52\":2}}],[\"template<>\",{\"1\":{\"47\":4}}],[\"template<typename\",{\"1\":{\"29\":1,\"30\":3,\"31\":1,\"32\":2,\"33\":2,\"36\":2,\"37\":1,\"40\":1,\"45\":4,\"47\":1,\"63\":2,\"69\":1}}],[\"terminate\",{\"1\":{\"51\":1,\"52\":1}}],[\"t<t>\",{\"1\":{\"45\":3}}],[\"typename\",{\"1\":{\"45\":2,\"69\":1}}],[\"typedef\",{\"1\":{\"45\":3}}],[\"type\",{\"1\":{\"40\":2,\"44\":1,\"45\":6,\"56\":1}}],[\"t被推导为int\",{\"1\":{\"36\":1}}],[\"t被推导为const\",{\"1\":{\"33\":1}}],[\"t被推到为const\",{\"1\":{\"33\":1}}],[\"t的类型为const\",{\"1\":{\"32\":1}}],[\"t和param的类型都是int\",{\"1\":{\"32\":3}}],[\"to\",{\"1\":{\"30\":1,\"31\":1,\"77\":1}}],[\"t是const\",{\"1\":{\"30\":3}}],[\"t是int\",{\"1\":{\"30\":5}}],[\"t\",{\"1\":{\"30\":3,\"31\":1,\"32\":2,\"33\":2,\"36\":1,\"37\":2,\"44\":1,\"45\":7,\"47\":1,\"52\":4,\"65\":1,\"69\":2}}],[\"t>\",{\"1\":{\"29\":1,\"30\":3,\"31\":1,\"32\":2,\"33\":2,\"36\":2,\"37\":1,\"45\":4,\"47\":1}}],[\"timestamp\",{\"1\":{\"24\":1}}],[\"ts>\",{\"1\":{\"63\":2,\"69\":1}}],[\"ts\",{\"1\":{\"23\":2,\"63\":2,\"69\":1}}],[\"target\",{\"1\":{\"21\":1}}],[\"table满了之后将其冻结成immutable\",{\"1\":{\"18\":1}}],[\"table\",{\"1\":{\"17\":1,\"18\":1}}],[\"tw​\",{\"1\":{\"13\":1}}],[\"txn\",{\"1\":{\"17\":1}}],[\"tx​\",{\"1\":{\"13\":1}}],[\"tx​创建一个额外的merkle证明∗πwrite​∗留在后面使用\",{\"1\":{\"12\":1}}],[\"tx\",{\"1\":{\"12\":2}}],[\"true\",{\"1\":{\"47\":1}}],[\"trusted\",{\"1\":{\"12\":1}}],[\"traits<it>\",{\"1\":{\"40\":1}}],[\"transactions\",{\"1\":{\"5\":1,\"9\":1}}],[\"tree对象\",{\"1\":{\"21\":1}}],[\"tree的每一层sstable进行检索\",{\"1\":{\"19\":1}}],[\"tree的数据结构\",{\"1\":{\"18\":1}}],[\"trie\",{\"1\":{\"9\":1}}],[\"tbd\",{\"1\":{\"1\":1}}],[\"system\",{\"1\":{\"67\":1}}],[\"sync\",{\"1\":{\"22\":1}}],[\"spv\",{\"1\":{\"75\":1}}],[\"spw2\",{\"1\":{\"68\":1,\"69\":1}}],[\"spw1就为空\",{\"1\":{\"68\":1}}],[\"spw1\",{\"1\":{\"68\":1,\"69\":1}}],[\"spw创建之后\",{\"1\":{\"68\":1}}],[\"spw\",{\"1\":{\"66\":1,\"68\":3,\"71\":1,\"72\":2,\"74\":1}}],[\"sp2指向对象的引用计数加1\",{\"1\":{\"65\":1}}],[\"sp\",{\"1\":{\"63\":1}}],[\"swap\",{\"1\":{\"52\":5}}],[\"swap是stl算法实现的一个关键组件\",{\"1\":{\"52\":1}}],[\"swap函数是noexcept的另一个绝佳用地\",{\"1\":{\"52\":1}}],[\"shared系列函数会比new要少分配一次内存\",{\"1\":{\"76\":1}}],[\"shared<reallybigtype>\",{\"1\":{\"76\":1}}],[\"shared<std\",{\"1\":{\"75\":1}}],[\"shared<widget>\",{\"1\":{\"68\":1,\"69\":1,\"71\":1,\"72\":1}}],[\"shared则会分配一整块内存单块\",{\"1\":{\"72\":1}}],[\"shared和std\",{\"1\":{\"69\":1}}],[\"shared总是会创建一个控制块\",{\"1\":{\"65\":1}}],[\"shared\",{\"1\":{\"44\":1,\"63\":3,\"64\":1,\"65\":6,\"66\":6,\"67\":16,\"68\":3,\"69\":1,\"71\":4,\"72\":1,\"74\":1,\"76\":8,\"77\":3}}],[\"sz>\",{\"1\":{\"55\":1}}],[\"sz的值在\",{\"1\":{\"55\":1}}],[\"sz的类型是std\",{\"1\":{\"40\":1}}],[\"sz\",{\"1\":{\"40\":1,\"55\":4}}],[\"somefunc是一个函数\",{\"1\":{\"33\":1}}],[\"somefunc\",{\"1\":{\"33\":3}}],[\"skipmap<keybytes\",{\"1\":{\"24\":1}}],[\"skiplist\",{\"1\":{\"24\":1}}],[\"skyzh\",{\"1\":{\"16\":2}}],[\"sety\",{\"1\":{\"57\":2}}],[\"setx\",{\"1\":{\"57\":2}}],[\"second\",{\"1\":{\"52\":2}}],[\"section对应的block的元数据列表\",{\"1\":{\"23\":1}}],[\"section字节数组反序列化成blockmeta数组\",{\"1\":{\"23\":1}}],[\"section中则是每个key\",{\"1\":{\"23\":1}}],[\"section包含的是具体的key\",{\"1\":{\"23\":1}}],[\"section包含的是具体的block数据\",{\"1\":{\"23\":1}}],[\"section的偏移值\",{\"1\":{\"23\":2}}],[\"section则是每个block的元数据\",{\"1\":{\"23\":1}}],[\"section\",{\"1\":{\"23\":6}}],[\"serialized\",{\"1\":{\"25\":1}}],[\"serializable\",{\"1\":{\"21\":1}}],[\"self\",{\"1\":{\"22\":5,\"23\":4,\"24\":1,\"25\":2}}],[\"sender<\",{\"1\":{\"21\":2}}],[\"sst\",{\"1\":{\"21\":2}}],[\"sstable相关的方法\",{\"1\":{\"23\":1}}],[\"sstable中最后一次修改的时间戳\",{\"1\":{\"23\":1}}],[\"sstable中的最大key\",{\"1\":{\"23\":1}}],[\"sstable中的最小key\",{\"1\":{\"23\":1}}],[\"sstable对应的磁盘中的文件\",{\"1\":{\"23\":1}}],[\"sstable的结构体\",{\"1\":{\"23\":1}}],[\"sstable的结构\",{\"1\":{\"23\":1}}],[\"sstable的状态\",{\"1\":{\"21\":1}}],[\"sstable是由block及其索引组成\",{\"1\":{\"23\":1}}],[\"sstable是lsm在磁盘中的核心数据结构\",{\"1\":{\"23\":1}}],[\"sstablebuilder\",{\"1\":{\"22\":1}}],[\"sstable路径\",{\"1\":{\"21\":1}}],[\"sstables\",{\"1\":{\"21\":2}}],[\"sstable大小\",{\"1\":{\"21\":1}}],[\"sstable\",{\"0\":{\"23\":1},\"1\":{\"17\":1,\"23\":2}}],[\"single\",{\"1\":{\"72\":1}}],[\"size\",{\"1\":{\"21\":2,\"22\":1,\"37\":1,\"40\":2,\"52\":1}}],[\"simulate\",{\"1\":{\"11\":1}}],[\"scan\",{\"1\":{\"17\":1,\"22\":1}}],[\"scaling\",{\"1\":{\"5\":1}}],[\"stock\",{\"1\":{\"63\":2}}],[\"storage\",{\"1\":{\"5\":1,\"8\":1}}],[\"stack\",{\"1\":{\"51\":1}}],[\"state\",{\"1\":{\"21\":2,\"25\":1}}],[\"static\",{\"1\":{\"17\":1}}],[\"std\",{\"1\":{\"36\":3,\"37\":2,\"40\":12,\"41\":3,\"43\":6,\"44\":1,\"45\":15,\"48\":2,\"49\":2,\"52\":1,\"55\":3,\"56\":1,\"61\":9,\"63\":8,\"64\":1,\"65\":5,\"66\":8,\"67\":13,\"68\":4,\"69\":8,\"71\":3,\"72\":2,\"74\":2,\"75\":2,\"76\":2,\"77\":19}}],[\"struct\",{\"1\":{\"21\":4,\"22\":1,\"23\":3,\"24\":1,\"25\":1,\"37\":1,\"45\":1,\"48\":3,\"52\":1,\"67\":1,\"77\":10}}],[\"string>\",{\"1\":{\"61\":2}}],[\"string>>\",{\"1\":{\"45\":2}}],[\"stringtable\",{\"1\":{\"61\":6}}],[\"string\",{\"1\":{\"17\":1,\"40\":5,\"45\":4,\"77\":5}}],[\"slimchain中交易完整的流程如下\",{\"1\":{\"11\":1}}],[\"slimchain的链下\",{\"1\":{\"8\":1}}],[\"slimchain的链上\",{\"1\":{\"8\":1}}],[\"slimchain组件主要包括三个部分\",{\"1\":{\"8\":1}}],[\"slimchain\",{\"0\":{\"5\":1}}],[\"override\",{\"1\":{\"48\":1}}],[\"observer\",{\"1\":{\"25\":1}}],[\"observers\",{\"1\":{\"8\":1}}],[\"object\",{\"1\":{\"61\":2,\"65\":1}}],[\"obj3\",{\"1\":{\"61\":3}}],[\"obj2\",{\"1\":{\"61\":2}}],[\"obj1\",{\"1\":{\"61\":7}}],[\"obj\",{\"1\":{\"25\":1}}],[\"operator=\",{\"1\":{\"60\":1,\"61\":4,\"77\":3}}],[\"operator\",{\"1\":{\"37\":1}}],[\"open\",{\"1\":{\"23\":1}}],[\"option<bloom>\",{\"1\":{\"23\":1}}],[\"option<bytes>\",{\"1\":{\"22\":1}}],[\"option<arc<blockcache>>\",{\"1\":{\"23\":2}}],[\"option<wal>\",{\"1\":{\"22\":1}}],[\"option<lsmmvccinner>\",{\"1\":{\"21\":1}}],[\"option<manifest>\",{\"1\":{\"21\":1}}],[\"options\",{\"1\":{\"21\":2}}],[\"of\",{\"1\":{\"23\":1,\"61\":3}}],[\"offsets\",{\"1\":{\"23\":1}}],[\"offset\",{\"1\":{\"23\":8}}],[\"off\",{\"0\":{\"5\":1},\"1\":{\"5\":1,\"8\":1}}],[\"on\",{\"0\":{\"5\":1},\"1\":{\"8\":1}}],[\"论文笔记\",{\"0\":{\"4\":1},\"1\":{\"5\":1}}],[\"日常笔记\",{\"0\":{\"2\":1}}],[\"😃\",{\"1\":{\"1\":1}}]],\"version\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
